<!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="https://fonts.cat.net/css?family=Lato:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="love, Python3.6, Django2.0, life"><link rel="alternate" href="/atom.xml" title="未来已来|共享未来" type="application/atom+xml"><meta name="description" content="[编程题] 彩色的砖块 时间限制：1秒 空间限制：32768K 小易有一些彩色的砖块。每种颜色由一个大写字母表示。各个颜色砖块看起来都完全一样。现在有一个给定的字符串s,s中每个字符代表小易的某个砖块的颜色。小易想把他所有的砖块排成一行。如果最多存在一对不同颜色的相邻砖块,那么这行砖块就很漂亮的。请你帮助小易计算有多少种方式将他所有砖块排成漂亮的一行。(如果两种方式所对应的砖块颜色序列是相同的,那"><meta name="keywords" content="Keep learning"><meta property="og:type" content="article"><meta property="og:title" content="未来已来|共享未来"><meta property="og:url" content="https://mvp099.github.io/2018/03/22/hello-world/index.html"><meta property="og:site_name" content="未来已来|共享未来"><meta property="og:description" content="[编程题] 彩色的砖块 时间限制：1秒 空间限制：32768K 小易有一些彩色的砖块。每种颜色由一个大写字母表示。各个颜色砖块看起来都完全一样。现在有一个给定的字符串s,s中每个字符代表小易的某个砖块的颜色。小易想把他所有的砖块排成一行。如果最多存在一对不同颜色的相邻砖块,那么这行砖块就很漂亮的。请你帮助小易计算有多少种方式将他所有砖块排成漂亮的一行。(如果两种方式所对应的砖块颜色序列是相同的,那"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2018-03-26T16:47:43.708Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="未来已来|共享未来"><meta name="twitter:description" content="[编程题] 彩色的砖块 时间限制：1秒 空间限制：32768K 小易有一些彩色的砖块。每种颜色由一个大写字母表示。各个颜色砖块看起来都完全一样。现在有一个给定的字符串s,s中每个字符代表小易的某个砖块的颜色。小易想把他所有的砖块排成一行。如果最多存在一对不同颜色的相邻砖块,那么这行砖块就很漂亮的。请你帮助小易计算有多少种方式将他所有砖块排成漂亮的一行。(如果两种方式所对应的砖块颜色序列是相同的,那"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"5.1.4",sidebar:{position:"left",display:"hide",offset:12,b2t:!1,scrollpercent:!1,onmobile:"ture"},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://mvp099.github.io/2018/03/22/hello-world/"><title> | 未来已来|共享未来</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div> <a href="https://mvp099.github.io/" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#fd6c6c;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">未来已来|共享未来</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">喜欢自己</p></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li><li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i><br> 日程表</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i><br> 站点地图</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i><br> 公益404</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://mvp099.github.io/2018/03/22/hello-world/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="淘淘の后院"><meta itemprop="description" content=""><meta itemprop="image" content="/uploads/001.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="未来已来|共享未来"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-22T18:24:48+08:00">2018-03-22</time> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">更新于&#58;</span> <time title="更新于" itemprop="dateModified" datetime="2018-03-27T00:47:43+08:00">2018-03-27</time></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">9,469 字</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">38 分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><p>[编程题] 彩色的砖块</p><p>时间限制：1秒</p><p>空间限制：32768K</p><pre><code>小易有一些彩色的砖块。每种颜色由一个大写字母表示。各个颜色砖块看起来都完全一样。现在有一个给定的字符串s,s中每个字符代表小易的某个砖块的颜色。小易想把他所有的砖块排成一行。如果最多存在一对不同颜色的相邻砖块,那么这行砖块就很漂亮的。请你帮助小易计算有多少种方式将他所有砖块排成漂亮的一行。(如果两种方式所对应的砖块颜色序列是相同的,那么认为这两种方式是一样的。)
例如: s = “ABAB”,那么小易有六种排列的结果:
“AABB”,”ABAB”,”ABBA”,”BAAB”,”BABA”,”BBAA”
其中只有”AABB”和”BBAA”满足最多只有一对不同颜色的相邻砖块。
</code></pre><p>输入描述:</p><p>输入包括一个字符串s,字符串s的长度length(1 ≤ length ≤ 50),s中的每一个字符都为一个大写字母(A到Z)。</p><pre><code>1
</code></pre><p>输出描述:</p><p>输出一个整数,表示小易可以有多少种方式。</p><pre><code>1
</code></pre><p>输入例子1:</p><p>ABAB</p><pre><code>1
</code></pre><p>输出例子1:</p><p>2</p><pre><code>1
</code></pre><p>解题思路</p><pre><code>麻痹，被题目蒙骗了，别以为是要排列啊，你想一下，两种类型的字母，是不是只有..AAABBB..或者…BBBAAA…这两种情况，三个类型字母特么怎么样都会被接触两次以上！如…AABBCC…
</code></pre><p>AC代码</p><p>a = raw_input(“”)<br>new = []<br>for i in range(len(a)):<br> new.append(a[i])<br>if len(set(new)) == 2:<br> print 2<br>elif len(set(new)) == 1:<br> print 1<br>else:<br> print 0</p><pre><code>1
2
3
4
5
6
7
8
9
10
</code></pre><p>[编程题] 等差数列</p><p>时间限制：1秒</p><p>空间限制：32768K</p><pre><code>如果一个数列S满足对于所有的合法的i,都有S[i + 1] = S[i] + d, 这里的d也可以是负数和零,我们就称数列S为等差数列。

小易现在有一个长度为n的数列x,小易想把x变为一个等差数列。小易允许在数列上做交换任意两个位置的数值的操作,并且交换操作允许交换多次。但是有些数列通过交换还是不能变成等差数列,小易需要判别一个数列是否能通过交换操作变成等差数列
</code></pre><p>输入描述:</p><p>输入包括两行,第一行包含整数n(2 ≤ n ≤ 50),即数列的长度。<br>第二行n个元素x<a href="0 ≤ x[i] ≤ 1000">i</a>,即数列中的每个整数。</p><pre><code>1
2
</code></pre><p>输出描述:</p><p>如果可以变成等差数列输出”Possible”,否则输出”Impossible”。</p><pre><code>1
</code></pre><p>输入例子1:</p><p>3<br>3 1 2</p><pre><code>1
2
</code></pre><p>输出例子1:</p><p>Possible</p><pre><code>1
</code></pre><p>解题思路</p><pre><code>先排个序，然后后者减去前者做个循环，看看每次减出来的值是不是只有一种，一种就等差
</code></pre><p>AC代码</p><p>a = int(raw_input(“”))<br>b = map(int,raw_input(“”).split(“ “))<br>c = sorted(b)<br>res = []<br>for i in range(len(c)-1):<br> res.append(c[i+1]-c[i])<br>if len(set(res)) == 1:<br> print ‘Possible’<br>else:<br> print ‘Impossible’</p><pre><code>1
2
3
4
5
6
7
8
9
10
</code></pre><p>[编程题] 交错01串</p><p>时间限制：1秒</p><p>空间限制：32768K</p><pre><code>如果一个01串任意两个相邻位置的字符都是不一样的,我们就叫这个01串为交错01串。例如: “1”,”10101”,”0101010”都是交错01串。
小易现在有一个01串s,小易想找出一个最长的连续子串,并且这个子串是一个交错01串。小易需要你帮帮忙求出最长的这样的子串的长度是多少。
</code></pre><p>输入描述:</p><p>输入包括字符串s,s的长度length(1 ≤ length ≤ 50),字符串中只包含’0’和’1’</p><pre><code>1
</code></pre><p>输出描述:</p><p>输出一个整数,表示最长的满足要求的子串长度。</p><pre><code>1
</code></pre><p>输入例子1:</p><p>111101111</p><pre><code>1
</code></pre><p>输出例子1:</p><p>3</p><pre><code>1
</code></pre><p>解题思路</p><pre><code>后者比较前者，如果字符串相同类型，那就重新计数，如果不同类型，且每次都要不同才符合要求，注意最后一点就是考虑一下全值一致的情况，列表为空单独判断
</code></pre><p>AC代码</p><p>a = raw_input(“”)<br>max_ = 1<br>res = []<br>for i in range(1,len(a)):<br> if a[i] != a[i-1]:<br> max_ +=1<br> res.append(max_)<br> else:<br> max_ = 1</p><p>if res == []:<br> print 1<br>else:<br> print max(res)</p><pre><code>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</code></pre><p>[编程题] 操作序列</p><p>时间限制：2秒</p><p>空间限制：32768K</p><pre><code>小易有一个长度为n的整数序列,a_1,…,a_n。然后考虑在一个空序列b上进行n次以下操作:
1、将a_i放入b序列的末尾
2、逆置b序列
小易需要你计算输出操作n次之后的b序列。
</code></pre><p>输入描述:</p><p>输入包括两行,第一行包括一个整数n(2 ≤ n ≤ 2*10^5),即序列的长度。<br>第二行包括n个整数a_i(1 ≤ a_i ≤ 10^9),即序列a中的每个整数,以空格分割。</p><pre><code>1
2
</code></pre><p>输出描述:</p><p>在一行中输出操作n次之后的b序列,以空格分割,行末无空格。</p><pre><code>1
</code></pre><p>输入例子1:</p><p>4<br>1 2 3 4</p><pre><code>1
2
</code></pre><p>输出例子1:</p><p>4 2 1 3</p><pre><code>1
</code></pre><p>解题思路</p><pre><code>分治思想，虽然我想的比较low，但是这样编写的时候速度快，分成左右两部分，考虑奇偶情况，写出规律，是一个索引递减的情况,还有需要注意的是，它数是一个个落下来的，不是全部落下来之后再挑选数字再逆序的，所以自己走一下流程，就可以观察到索引的变化
</code></pre><p>AC代码</p><p>n = int(raw_input(“”))<br>a = map(int,raw_input(“”).split(“ “))<br>b_left = []<br>b_right = []</p><h1 id="这一段虽然可行，但是复杂度太高，AC-60"><a href="#这一段虽然可行，但是复杂度太高，AC-60" class="headerlink" title="这一段虽然可行，但是复杂度太高，AC 60%"></a>这一段虽然可行，但是复杂度太高，AC 60%</h1><p>#for i in a:</p><h1 id="b-append-i"><a href="#b-append-i" class="headerlink" title="b.append(i)"></a>b.append(i)</h1><h1 id="b-reverse"><a href="#b-reverse" class="headerlink" title="b.reverse()"></a>b.reverse()</h1><p>#print “ “.join(map(str,b))</p><p>if len(a)%2 == 0:<br> b_left = [a[k] for k in range(len(a)-1,0,-2)]<br> b_right = [a[k] for k in range(0,len(a),2)]<br>else:<br> b_left = [a[k] for k in range(len(a)-1,-1,-2)]<br> b_right = [a[k] for k in range(1,len(a),2)]</p><p>print “ “.join(map(str,b_left+b_right))</p><pre><code>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</code></pre><p>[编程题] 独立的小易</p><p>时间限制：1秒</p><p>空间限制：32768K</p><pre><code>小易为了向他的父母表现他已经长大独立了,他决定搬出去自己居住一段时间。一个人生活增加了许多花费: 小易每天必须吃一个水果并且需要每天支付x元的房屋租金。当前小易手中已经有f个水果和d元钱,小易也能去商店购买一些水果,商店每个水果售卖p元。小易为了表现他独立生活的能力,希望能独立生活的时间越长越好,小易希望你来帮他计算一下他最多能独立生活多少天。
</code></pre><p>输入描述:</p><p>输入包括一行,四个整数x, f, d, p(1 ≤ x,f,d,p ≤ 2 * 10^9),以空格分割</p><pre><code>1
</code></pre><p>输出描述:</p><p>输出一个整数, 表示小易最多能独立生活多少天。</p><pre><code>1
</code></pre><p>输入例子1:</p><p>3 5 100 10</p><pre><code>1
</code></pre><p>输出例子1:</p><p>11</p><pre><code>1
</code></pre><p>解题思路</p><pre><code>考虑水果还没吃完就先房租交不起的情况吧，然后就是小学数学，写个方程求解，ok

D*x + (D-f)*p =d, 反解D就是能活下去的天数
</code></pre><p>AC代码</p><p>x,f,d,p = map(int,raw_input(“”).split(“ “))<br>if d/x &lt; f:<br> print d/x<br>else:<br> print (d+f*p)/(x+p)</p><pre><code>1
2
3
4
5
</code></pre><p>[编程题] 堆棋子</p><p>时间限制：1秒</p><p>空间限制：32768K</p><pre><code>小易将n个棋子摆放在一张无限大的棋盘上。第i个棋子放在第x[i]行y[i]列。同一个格子允许放置多个棋子。每一次操作小易可以把一个棋子拿起并将其移动到原格子的上、下、左、右的任意一个格子中。小易想知道要让棋盘上出现有一个格子中至少有i(1 ≤ i ≤ n)个棋子所需要的最少操作次数.
</code></pre><p>输入描述:</p><p>输入包括三行,第一行一个整数n(1 ≤ n ≤ 50),表示棋子的个数<br>第二行为n个棋子的横坐标x<a href="1 ≤ x[i] ≤ 10^9">i</a><br>第三行为n个棋子的纵坐标y<a href="1 ≤ y[i] ≤ 10^9">i</a></p><pre><code>1
2
3
</code></pre><p>输出描述:</p><p>输出n个整数,第i个表示棋盘上有一个格子至少有i个棋子所需要的操作数,以空格分割。行末无空格</p><p>如样例所示:<br>对于1个棋子: 不需要操作<br>对于2个棋子: 将前两个棋子放在(1, 1)中<br>对于3个棋子: 将前三个棋子放在(2, 1)中<br>对于4个棋子: 将所有棋子都放在(3, 1)中</p><pre><code>1
2
3
4
5
6
7
</code></pre><p>输入例子1:</p><p>4<br>1 2 4 9<br>1 1 1 1</p><pre><code>1
2
3
</code></pre><p>输出例子1:</p><p>0 1 3 10</p><pre><code>1
</code></pre><p>解题思路</p><pre><code>对于一个k,我们找一个坐标(x, y)让k个棋子距离这个坐标的曼哈顿距离之和最小。注意到x和y其实是独立的,考虑枚举棋盘上所有可能得坐标(x[i], y[j]),计算这个坐标到所有棋子的距离分别是多少,然后维护k个棋子对于这个坐标最小曼哈顿距离和即可。—这是抄别人的分析，我自己还在考虑这个问题，他们都用暴力枚举的方法都可行，我得方法中，取了棋子落的上下边界进行遍历，然后有种knn的思想混杂在里面，代码没问题，但是内存超了，后续我再想想
</code></pre><p>AC 60%，内存超了</p><p>n = int(raw_input(“”))<br>x = map(int,raw_input(“”).split(“ “))<br>y = map(int,raw_input(“”).split(“ “))<br>gps = zip(x,y)</p><p>guess = []<br>for i in xrange(min(x),max(x)+1):<br> for j in xrange(min(y),max(y)+1):<br> guess.append((i,j))</p><p>result = []<br>for i in xrange(1,n+1):<br> res = []<br> for j in guess:<br> res.append(sum(sorted(map(lambda x:abs(x[0]-j[0])+abs(x[1]-j[1]),gps))[:i]))<br> result.append(min(res))</p><p>print “ “.join(map(str,result))</p><pre><code>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</code></pre><p>AC代码</p><p>def ManhattanDistance(x1, y1, x2, y2):<br> return abs(x1 - x2) + abs(y1 - y2)</p><p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br> n = int(input())<br> x = [int(i.strip()) for i in raw_input().split(‘ ‘)]<br> y = [int(i.strip()) for i in raw_input().split(‘ ‘)]<br> ans = [10 * <em>10]</em> n<br> for i in range(n):<br> for j in range(n):<br> tmp = []<br> s = 0<br> for k in range(n):<br> tmp.append(ManhattanDistance(x[i], y[j], x[k], y[k]))<br> tmp.sort()<br> for k in range(n):<br> s += tmp[k]<br> ans[k] = min(ans[k], s)<br> for i in ans:<br> print i,</p><pre><code>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</code></pre><p>[编程题] 疯狂队列</p><p>时间限制：1秒</p><p>空间限制：32768K</p><pre><code>小易老师是非常严厉的,它会要求所有学生在进入教室前都排成一列,并且他要求学生按照身高不递减的顺序排列。有一次,n个学生在列队的时候,小易老师正好去卫生间了。学生们终于有机会反击了,于是学生们决定来一次疯狂的队列,他们定义一个队列的疯狂值为每对相邻排列学生身高差的绝对值总和。由于按照身高顺序排列的队列的疯狂值是最小的,他们当然决定按照疯狂值最大的顺序来进行列队。现在给出n个学生的身高,请计算出这些学生列队的最大可能的疯狂值。小易老师回来一定会气得半死。
</code></pre><p>输入描述:</p><p>输入包括两行,第一行一个整数n(1 ≤ n ≤ 50),表示学生的人数<br>第二行为n个整数h<a href="1 ≤ h[i] ≤ 1000">i</a>,表示每个学生的身高</p><pre><code>1
2
</code></pre><p>输出描述:</p><p>输出一个整数,表示n个学生列队可以获得的最大的疯狂值。</p><p>如样例所示:<br>当队列排列顺序是: 25-10-40-5-25, 身高差绝对值的总和为15+30+35+20=100。<br>这是最大的疯狂值了。</p><pre><code>1
2
3
4
5
</code></pre><p>输入例子1:</p><p>5<br>5 10 25 40 25</p><pre><code>1
2
</code></pre><p>输出例子1:</p><p>100</p><pre><code>1
</code></pre><p>解题思路</p><pre><code>先排序，挑选中间值，然后左右两边交替换值，重新进一个队列里面。你想象一下，如何使交替的人差值最大，可以考虑对称的思想，最大的最小的，然后和次小的，然后和次大的。。。。
</code></pre><p>AC代码</p><p>n = int(raw_input(“”))<br>line = map(int ,raw_input(“”).split(“ “))<br>line.sort()<br>mid = len(line)/2<br>left = line[0:mid]<br>right = line[mid+1:]<br>newline = []</p><p>def sumlist(list_):<br> res = 0<br> for i in range(1,len(list_)):<br> res +=abs(list_[i]-list_[i-1])<br> return res</p><p>if len(line)%2 == 1:<br> while left and right:<br> newline.append(right.pop(0))<br> newline.append(left.pop())<br> newline.append(line[mid])<br> print sumlist(newline)</p><p>else:<br> while left and right:<br> newline.append(left.pop())<br> newline.append(right.pop(0))<br> newline.append(left.pop())<br> newline.append(line[mid])<br> print sumlist(newline)</p><pre><code>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</code></pre><p>[编程题] 小易喜欢的数列</p><p>时间限制：1秒</p><p>空间限制：32768K</p><pre><code>小易非常喜欢拥有以下性质的数列:
1、数列的长度为n
2、数列中的每个数都在1到k之间(包括1和k)
3、对于位置相邻的两个数A和B(A在B前),都满足(A &lt;= B)或(A mod B != 0)(满足其一即可)
例如,当n = 4, k = 7
那么{1,7,7,2},它的长度是4,所有数字也在1到7范围内,并且满足第三条性质,所以小易是喜欢这个数列的
但是小易不喜欢{4,4,4,2}这个数列。小易给出n和k,希望你能帮他求出有多少个是他会喜欢的数列。
</code></pre><p>输入描述:</p><p>输入包括两个整数n和k(1 ≤ n ≤ 10, 1 ≤ k ≤ 10^5)</p><pre><code>1
</code></pre><p>输出描述:</p><p>输出一个整数,即满足要求的数列个数,因为答案可能很大,输出对1,000,000,007取模的结果。</p><pre><code>1
</code></pre><p>输入例子1:</p><p>2 2</p><pre><code>1
</code></pre><p>输出例子1:</p><p>3</p><pre><code>1
</code></pre><p>AC代码</p><p>目前，python，我特么AC不出来啊，求助</p><p>1.<br>一种双核CPU的两个核能够同时的处理任务，现在有n个已知数据量的任务需要交给CPU处理，假设已知CPU的每个核1秒可以处理1kb，每个核同时只能处理一项任务。n个任务可以按照任意顺序放入CPU进行处理，现在需要设计一个方案让CPU处理完这批任务所需的时间最少，求这个最小的时间。<br>输入描述:</p><p>输入包括两行：<br>第一行为整数n(1 ≤ n ≤ 50)<br>第二行为n个整数length<a href="1024 ≤ length[i] ≤ 4194304">i</a>，表示每个任务的长度为length[i]kb，每个数均为1024的倍数。</p><p>输出描述:</p><p>输出一个整数，表示最少需要处理的时间</p><p>输入例子:</p><p>5<br>3072 3072 7168 3072 1024</p><p>输出例子:</p><p>9216</p><p>个人思路：</p><p>1.选择最小的 2 个任务，2 个cup开始对这两个任务进行处理<br> 1.1.如果两个同时完成，则找剩下任务中最小的 2 个任务，继续开始任务处理<br> 1.2.直到剩余任务量为 1 个或者 2 个<br> 2.1.如果一个任务完成，则找剩下任务中最小的 1 个任务，继续开始任务处理</p><p>经过以上思考，我开始着手写代码，最终测试结果为 30% 通过率。</p><p>也是从这道题的正确代码得到教训，我自己写的代码提高的空间太大了。一是对待问题选择的思路，二是代码的简洁性，既然是 python，为什么不发挥它的优势呢？<br>正确结果 (牛客网 id：Mr.Mary)：</p><p>n=int(raw_input())</p><p>arr=[int(i) for i in raw_input().strip().split()]</p><p>h=set(arr)</p><p>for i in arr:</p><pre><code>for j in list(h):

    h.add(i+j)
</code></pre><p>h=[i for i in h if i&gt;=sum(arr)/2]</p><p>print min(h)<br>巧妙的用到了 python 的 set 和 list。</p><p>先将输入的任务用 set 进行处理，变成无重复的任务集合 h</p><p>然后增加 h 里面处理时间，例如题目中例子增加到最后， h 的结果为</p><p>h set([3072, 7168, 4096, 15360, 19456, 23552, 5120, 8192, 12288, 16384, 20480, 24576, 1024, 6144, 9216, 13312, 17408, 21504, 2048, 11264, 10240, 14336, 18432])</p><p>两个 cup，以输入的任务时间总和除以 2 为基准对 h 进行过滤，最后再取出最小的值，即为所需答案。</p><p>关键在于整合任务的时间、以 sum/2 为基准进行时间筛选。</p><p>2.<br>终于到周末啦！小易走在市区的街道上准备找朋友聚会，突然服务器发来警报,小易需要立即回公司修复这个紧急bug。假设市区是一个无限大的区域，每条街道假设坐标是(X，Y)，小易当前在(0，0)街道，办公室在(gx,gy)街道上。小易周围有多个出租车打车点，小易赶去办公室有两种选择，一种就是走路去公司，另外一种就是走到一个出租车打车点，然后从打车点的位置坐出租车去公司。每次移动到相邻的街道(横向或者纵向)走路将会花费walkTime时间，打车将花费taxiTime时间。小易需要尽快赶到公司去，现在小易想知道他最快需要花费多少时间去公司。<br>输入描述:</p><p>输入数据包括五行:</p><p>第一行为周围出租车打车点的个数n(1 ≤ n ≤ 50)</p><p>第二行为每个出租车打车点的横坐标tX[i] (-10000 ≤ tX[i] ≤ 10000)</p><p>第三行为每个出租车打车点的纵坐标tY[i] (-10000 ≤ tY[i] ≤ 10000)</p><p>第四行为办公室坐标gx,gy(-10000 ≤ gx,gy ≤ 10000),以空格分隔</p><p>第五行为走路时间walkTime(1 ≤ walkTime ≤ 1000)和taxiTime(1 ≤ taxiTime ≤ 1000),以空格分隔</p><p>输出描述:</p><p>输出一个整数表示，小易最快能赶到办公室的时间</p><p>输入例子:</p><p>2<br>-2 -2<br>0 -2<br>-4 -2<br>15 3</p><p>输出例子:</p><p>42</p><p>个人思路：<br>x 或者 y 每变化 +- 1 ,walktime 和 taxitime 都增加一次<br>统计 0,0 到出租车点再到公司的所有时间，取最小值<br>这要分多少种情况啊：16，但这16种情况里面，有几种下面的计算性质都是一样的<br>我的这个思路简单以至于想复杂。<br>正确答案 (牛客网 id：Panzerfaust)：</p><p>while True:</p><pre><code>line = sys.stdin.readline()

if line.strip() == &quot;&quot;:

    break

num = int(line)



x = [int(var) for var in sys.stdin.readline().split(&quot; &quot;)]

y = [int(var) for var in sys.stdin.readline().split(&quot; &quot;)]

locate = [int(var) for var in sys.stdin.readline().split(&quot; &quot;)]

speed = [int(var) for var in sys.stdin.readline().split(&quot; &quot;)]

time = [speed[0] * (abs(locate[0]) + abs(locate[1]))]

for i in range(num):

    time_num = speed[1] * (abs(x[i] - locate[0]) + abs(y[i] - locate[1])) + speed[0] * (abs(x[i]) + abs(y[i]))

    time.append(time_num)

print(min(time))
</code></pre><p>首先学习的是输入的格式怎么写</p><p>然后，这道题其实是很简单的。注意 abs 的使用，我是对这个考虑太多了。直接就坐标加减即可，别想太多别想太多。</p><p>3.<br>在幼儿园有n个小朋友排列为一个队伍，从左到右一个挨着一个编号为(0~n-1)。其中有一些是男生，有一些是女生，男生用’B’表示，女生用’G’表示。小朋友们都很顽皮，当一个男生挨着的是女生的时候就会发生矛盾。作为幼儿园的老师，你需要让男生挨着女生或者女生挨着男生的情况最少。你只能在原队形上进行调整，每次调整只能让相邻的两个小朋友交换位置，现在需要尽快完成队伍调整，你需要计算出最少需要调整多少次可以让上述情况最少。例如：<br>GGBBG -&gt; GGBGB -&gt; GGGBB<br>这样就使之前的两处男女相邻变为一处相邻，需要调整队形2次<br>输入描述:</p><p>输入数据包括一个长度为n且只包含G和B的字符串.n不超过50.</p><p>输出描述:</p><p>输出一个整数，表示最少需要的调整队伍的次数</p><p>输入例子:</p><p>GGBBG</p><p>输出例子:</p><p>2</p><p>个人思路：</p><ol><li>如果 GB 相邻为 1 次，则 times = 0</li><li>相邻 &gt; 1 次，判断哪个在前，哪一个在后</li><li>移动 设计两个 flag1 = ‘G’, flag2 = ‘B’，前后开始判断<br>结果这一题没有思考下去，就卡在我这个 flag 的选取上了。<br>正确答案 (牛客网 id：Zero2one)：</li></ol><p>‘’’</p><p>只需要计算字符串中第一个’B’移动到第一个位置需要多少次,</p><p>第二个’B’移动到第二个位置需要多少次…依次类推</p><p>同理，对于G也是一样，</p><p>然后取二者中的较小值即可</p><p>‘’’</p><p>import sys</p><p>if <strong>name</strong> == ‘<strong>main</strong>‘:</p><pre><code>S = sys.stdin.readline().strip()

s = [i for i in S]

loctionsB = loctionsG = icountB = icountG = 0

for i in xrange (len(s)):

    if s[i] == &apos;B&apos;:

        icountB += i - loctionsB

        loctionsB += 1

    else:

        icountG += i - loctionsG

        loctionsG += 1



print min(icountB,icountG)
</code></pre><p>把 B 移到最左边：开始遍历，找到 B，计算移到现在最左边非 B 的位置，记录</p><p>另一个思路（牛客网 id：于晨晨）</p><p>最终目标是将男孩移到最左边，或者将女孩移到最左边。<br>如果有B个男孩，则移到最左边的index分别为：0,1,2…B-1,所以所有index的和为（B-1）*B/2<br>一次遍历，计算目前男孩所在的index的和为sumB，则sumB减去上面的和就是所求的结果。<br>因此只要一次遍历，计算男孩所在的男孩的个数和男孩所在的index的和，求之差就行了。女孩同理。最后求最小值。</p><p>4.<br>易有一个长度为n序列，小易想移除掉里面的重复元素，但是小易想是对于每种元素保留最后出现的那个。小易遇到了困难,希望你来帮助他。<br>输入描述:</p><p>输入包括两行：<br>第一行为序列长度n(1 ≤ n ≤ 50)<br>第二行为n个数sequence<a href="1 ≤ sequence[i] ≤ 1000">i</a>，以空格分隔</p><p>输出描述:</p><p>输出消除重复元素之后的序列，以空格分隔，行末无空格</p><p>输入例子:</p><p>9<br>100 100 100 99 99 99 100 100 100</p><p>输出例子:</p><p>99 100</p><p>个人思路：</p><p>我就从后往前找，当一个元素找到第一个相同的元素后，就把它拿出来，break，下一个。</p><p>测试通过率 20%，题目测试例子以及基本的例子我都符合要求，但还是不正确。</p><p>while n &gt;= len(set(arr))-1:<br> flag = arr[length-j]<br> for i in range(length-j-1, -1, -1):<br> if flag == arr[i]:<br> del arr[i]<br> m += 1<br> length -= 1<br> n -= m<br> j += 1</p><p>我就采用立 flag，然后删除，index 变化的方法来完成。</p><p>正确答案(牛客网id：大虫逗你玩)：</p><p>import sys</p><p>num1=int(raw_input().strip())</p><p>num2=map(int,sys.stdin.readline().strip().split())</p><p>num2.reverse()</p><p>num2_new=list(set(num2))</p><p>num2_new.sort(key=num2.index)</p><p>num2_new.reverse()</p><p>for i in num2_new:</p><pre><code>print i,
</code></pre><p>这个我看到是用反转，也就是倒着、逆向来，又用到 set，再用 num2 的下标作为关键字进行排序，注意：这里的 num2 是输入的数组反转之后的新数组，因此</p><p>按这个反转的下标排序后，再次对 num2_new 进行反转，下标就返回到原来输入的 num2 咯。</p><p>这里的关键就是，会利用排序 sort 的参数灵活解决问题。</p><p>5.<br>小易拥有一个拥有魔力的手环上面有n个数字(构成一个环),当这个魔力手环每次使用魔力的时候就会发生一种奇特的变化：每个数字会变成自己跟后面一个数字的和(最后一个数字的后面一个数字是第一个),一旦某个位置的数字大于等于100就马上对100取模(比如某个位置变为103,就会自动变为3).现在给出这个魔力手环的构成，请你计算出使用k次魔力之后魔力手环的状态。<br>输入描述:</p><p>输入数据包括两行：<br>第一行为两个整数n(2 ≤ n ≤ 50)和k(1 ≤ k ≤ 2000000000),以空格分隔<br>第二行为魔力手环初始的n个数，以空格分隔。范围都在0至99.</p><p>输出描述:</p><p>输出魔力手环使用k次之后的状态，以空格分隔，行末无空格。</p><p>输入例子:</p><p>3 2<br>1 2 3</p><p>输出例子:</p><p>8 9 7</p><p>个人思路：</p><p>思路 如例子<br> 第一次 + [2, 3, 1] = [3, 5, 4]<br> 第二次 + [5, 4, 3] = [8, 9, 7]</p><p>我还是用自己所掌握的，采用一个临时数组，把第一个元素删除，然后添加到尾部，进行加法。</p><p>转换为列表的下标变化进行解决。结果通过率为 10%，告诉我未在规定时间内完成。怕是循环太复杂了<br>正确答案(牛客网 id：牛客游客)：</p><p>这道题貌似用 python，牛客显示没有人目前做对啊，唯一的这个“牛客游客”，我去跑了一下他的代码，通过率 80%，也是时间超出。</p><p>那不考虑时间，我的现在自己分析起来也是可以的：</p><p>num_times = [int(i) for<br>i in raw_input().strip().split()]</p><p>c = [int(j) for<br>j in raw_input().strip().split()]</p><p>length = num_times[0]</p><p>times = num_times[1]</p><p>l = 0</p><p>while<br>l &lt; times:</p><pre><code>temp = []

for
</code></pre><p>m in c:</p><pre><code>    temp.append(m)

first = temp[0]

del temp[0]

temp.append(first)

o = 0

while
</code></pre><p>o &lt; length:</p><pre><code>s = temp[o] + c[o]

if
</code></pre><p>s &gt;= 100:</p><pre><code>        s = int(s) % 100

    c[o] = s

    o += 1

l += 1
</code></pre><p>t = ‘ ‘.join(str(i) for<br>i in c)</p><p>print t<br>这道题就算处于还未解决中吧。</p><p>6.<br>现在有n位工程师和6项工作(编号为0至5)，现在给出每个人能够胜任的工作序号表(用一个字符串表示，比如：045，表示某位工程师能够胜任0号，4号，5号工作)。现在需要进行工作安排，每位工程师只能被安排到自己能够胜任的工作当中去，两位工程师不能安排到同一项工作当中去。如果两种工作安排中有一个人被安排在的工作序号不一样就被视为不同的工作安排，现在需要计算出有多少种不同工作安排计划。<br>输入描述:</p><p>输入数据有n+1行：<br>第一行为工程师人数n(1 ≤ n ≤ 6)<br>接下来的n行，每行一个字符串表示第i(1 ≤ i ≤ n)个人能够胜任的工作(字符串不一定等长的)</p><p>输出描述:</p><p>输出一个整数，表示有多少种不同的工作安排方案</p><p>输入例子:</p><p>6<br>012345<br>012345<br>012345<br>012345<br>012345<br>012345</p><p>输出例子:</p><p>720</p><p>个人思路：</p><p>领悟到做题之前，一定要搞明白题目的意思。讲真这一题是十二道题中唯一一个没有明确思路的，不说明确思路，都不知道大致怎么去搞</p><p>摘自牛客解析：</p><ul><li>现在有n位工程师和6项工作(编号为0至5)，</li><li>现在给出每个人能够胜任的工作序号表(用一个字符串表示，比如：045，表示某位工程师能够胜任0号，4号，5号工作)。</li><li>现在需要进行工作安排，每位工程师只能被安排到自己能够胜任的工作当中去，两位工程师不能安排到同一项工作当中去。</li><li>如果两种工作安排中有一个人被安排在的工作序号不一样就被视为不同的工作安排，</li><li>现在需要计算出有多少种不同工作安排计划。</li></ul><p>题目不难，主要是题意太模糊。有两点很可能阻拦了你AC这个题：<br>1、所有工程师都必须有事可做。<br>2、不必所有事都要做。</p><p>#题意有两个地方没说清楚：</p><h1 id="1、一个人只能做一项工程，而不能分饰两角；"><a href="#1、一个人只能做一项工程，而不能分饰两角；" class="headerlink" title="1、一个人只能做一项工程，而不能分饰两角；"></a>1、一个人只能做一项工程，而不能分饰两角；</h1><h1 id="2、有几个工程师，每个工程师有一个工作即满足题意，不用6项工作全部都要有人做。"><a href="#2、有几个工程师，每个工程师有一个工作即满足题意，不用6项工作全部都要有人做。" class="headerlink" title="2、有几个工程师，每个工程师有一个工作即满足题意，不用6项工作全部都要有人做。"></a>2、有几个工程师，每个工程师有一个工作即满足题意，不用6项工作全部都要有人做。</h1><p>正确答案(牛客网 id：zero_python)：</p><p>n = int(raw_input().strip())</p><p>work = [raw_input().strip() for _ in range(n)]</p><p>def dfs(n, work, res):</p><pre><code># 为第n位工程师安排工作

ans = 0

for ws in work[n]: # 第 n 个工程师能做 work[n]

    if ws not in res: # 如果ws没有被安排. 

        if n == 0: # 如果是最后一个工程师

            ans += 1 # 能够安排的数量 +1. 

        else:

            ans += dfs(n-1, work, res+[ws])

return ans
</code></pre><p>print dfs(n-1, work, [])</p><p>7.<br>小易最近在数学课上学习到了集合的概念,集合有三个特征：1.确定性 2.互异性 3.无序性.<br>小易的老师给了小易这样一个集合：<br>S = { p/q | w ≤ p ≤ x, y ≤ q ≤ z }<br>需要根据给定的w，x，y，z,求出集合中一共有多少个元素。小易才学习了集合还解决不了这个复杂的问题,需要你来帮助他。<br>输入描述:</p><p>输入包括一行：<br>一共4个整数分别是w(1 ≤ w ≤ x)，x(1 ≤ x ≤ 100)，y(1 ≤ y ≤ z)，z(1 ≤ z ≤ 100).以空格分隔</p><p>输出描述:</p><p>输出集合中元素的个数</p><p>输入例子:</p><p>1 10 1 1</p><p>输出例子:</p><p>10</p><p>个人思路：</p><p>例子为： p 为一个数组 [1,2,3,4,5,6,7,8,9,10]</p><pre><code>q 为一个数组 [1]
</code></pre><p>集合为： [1,2,3,4,5,6,7,8,9,10]</p><p>就循环 p、q，想除，放入某数组，最后 set 处理一下，over<br>正确答案(自己)：</p><p>wxyz = [int(i) for i in raw_input().strip().split()]</p><p>w = wxyz[0]</p><p>x = wxyz[1]</p><p>y = wxyz[2]</p><p>z = wxyz[3]</p><p>p = []</p><p>q = []</p><p>for i in range(w, x+1, 1):</p><pre><code>p.append(i)
</code></pre><p>for j in range(y, z+1, 1):</p><pre><code>q.append(j)
</code></pre><p>result = []</p><p>for i in range(0, len(p), 1):</p><pre><code>for j in range(0, len(q), 1):

    data = float(p[i]) / q[j]

    result.append(data)
</code></pre><p>end = set(result)</p><p>print len(end)<br>其实遇见的问题只有一个：分子必须转化成 float 类型！</p><p>8.<br>常规的表达式求值，我们都会根据计算的优先级来计算。比如<em>/的优先级就高于+-。但是小易所生活的世界的表达式规则很简单，从左往右依次计算即可，而且小易所在的世界没有除法，意味着表达式中没有/，只有(+, - 和</em> )。现在给出一个表达式，需要你帮忙计算出小易所在的世界这个表达式的值为多少<br>输入描述:</p><p>输入为一行字符串，即一个表达式。其中运算符只有-,+,*。参与计算的数字只有0~9.<br>保证表达式都是合法的，排列规则如样例所示。</p><p>输出描述:</p><p>输出一个数，即表达式的值</p><p>输入例子:</p><p>3+5*7</p><p>输出例子:</p><p>56</p><p>个人思路：</p><p>双杀两道题，这一个也不是很难，符号都会是单数下标，数字都是偶数下标，又想起了语法分析器…</p><p>虽然这题我写出来了，用了删除思想。</p><p>if make[0] == plus:<br> temp += int(number[1])<br> del make[0]<br> del number[1]</p><p>但是与现在看到的其他代码相比，还是决定放上人家的。</p><p>正确答案(牛客网 id：你的响亮的名字)：</p><p>expression = raw_input()</p><p>expression = list(expression)</p><p>res = int(expression[0])</p><p>for i in range(len(expression)- 2):</p><pre><code>if expression[i+1] == &apos;+&apos; :

    res = res + int(expression[i+2])

if expression[i+1] == &apos;-&apos; :

    res = res - int(expression[i+2])

if expression[i+1] == &apos;*&apos; :

    res = res * int(expression[i+2])

i= i + 2
</code></pre><p>print res<br>简介，清楚，明白，就是从左往右，以此计算。没有考虑太多，值得学习。</p><p>9.<br>小易有一块n*n的棋盘，棋盘的每一个格子都为黑色或者白色，小易现在要用他喜欢的红色去涂画棋盘。小易会找出棋盘中某一列中拥有相同颜色的最大的区域去涂画，帮助小易算算他会涂画多少个棋格。<br>输入描述:</p><p>输入数据包括n+1行：</p><p>第一行为一个整数n(1 ≤ n ≤ 50),即棋盘的大小</p><p>接下来的n行每行一个字符串表示第i行棋盘的颜色，’W’表示白色，’B’表示黑色</p><p>输出描述:</p><p>输出小易会涂画的区域大小</p><p>输入例子:</p><p>3<br>BWW<br>BBB<br>BWB</p><p>输出例子:</p><p>3</p><p>个人思路：</p><p>一开始理解错了，以为求的是一列里面相同颜色最多的棋子，结果后来测试用例 30% ，又讨论了一下，结果明白是：相邻最大相同。</p><p>对于一列，遍历统计<br>正确答案(牛客网 id：Panzerfaust)：</p><p>import sys</p><p>while True:</p><pre><code>line = sys.stdin.readline().strip()

if line ==&quot;&quot;:

    break

num = int(line)

arr= []

for i in range(num):

    arr.append(sys.stdin.readline().strip())

result = []

for i in range(num):

    B_count =[1]

    for j in range(0,num-1):

        if arr[j][i] == arr[j+1][i]:

            B_count[-1]+=1

        else:

            B_count.append(1)

    result.append(max(B_count))

print(max(result))
</code></pre><p>这个是真的妙，统计连续相同的次数放在数组末尾，如果连续相同的被打断了，给数组新加一个统计 1，然后，在新的这个 1 上面，继续进行统计。</p><p>10.<br>小易参与了一个记单词的小游戏。游戏开始系统提供了m个不同的单词，小易记忆一段时间之后需要在纸上写出他记住的单词。小易一共写出了n个他能记住的单词，如果小易写出的单词是在系统提供的，将获得这个单词长度的平方的分数。注意小易写出的单词可能重复，但是对于每个正确的单词只能计分一次。<br>输入描述:</p><p>输入数据包括三行：</p><p>第一行为两个整数n(1 ≤ n ≤ 50)和m(1 ≤ m ≤ 50)。以空格分隔</p><p>第二行为n个字符串，表示小易能记住的单词，以空格分隔，每个单词的长度小于等于50。</p><p>第三行为m个字符串，系统提供的单词，以空格分隔，每个单词的长度小于等于50。</p><p>输出描述:</p><p>输出一个整数表示小易能获得的分数</p><p>输入例子:</p><p>3 4<br>apple orange strawberry<br>strawberry orange grapefruit watermelon</p><p>输出例子:</p><p>136</p><p>个人思路：</p><p>一句话，这个简单啊。使用 list 和 set 就好。但是测试通过 80%<br>正确答案(自己 &amp;&amp; id：啊杜)：</p><p>这是显示的测试通过的</p><p>nm = raw_input().split()</p><p>n = int(nm[0])</p><p>m = int(nm[1])</p><p>string = list(set(raw_input().split()))</p><p>sysStr = raw_input().split()</p><p>result = 0</p><p>for i in string:</p><pre><code>for j in range(m):

    if i==sysStr[j]:

        result += len(i)**2
</code></pre><p>print result</p><p>而我的这次还特意写了一个函数：</p><p>[python] view plain copy</p><pre><code>def score(question, answers):  
    s = 0  
    answer = list(set(answers))  
    for ans in answer:  
        if ans in question:  
            s += len(ans)**2  
    return s  


num = [int(i) for i in raw_input().strip().split()]  
answer = [a for a in raw_input().strip().split()]  
question = [q for q in raw_input().strip().split()]  
print score(question, answer)  
</code></pre><p>现在一分析，人家那里没用 list 和 set，直接用了 for 循环。</p><p>11.<br>小易有n块砖块，每一块砖块有一个高度。小易希望利用这些砖块堆砌两座相同高度的塔。为了让问题简单，砖块堆砌就是简单的高度相加，某一块砖只能使用在一座塔中一次。小易现在让能够堆砌出来的两座塔的高度尽量高，小易能否完成呢。<br>输入描述:</p><p>输入包括两行：<br>第一行为整数n(1 ≤ n ≤ 50)，即一共有n块砖块<br>第二行为n个整数，表示每一块砖块的高度height[i] (1 ≤ height[i] ≤ 500000)</p><p>输出描述:</p><p>如果小易能堆砌出两座高度相同的塔，输出最高能拼凑的高度，如果不能则输出-1.<br>保证答案不大于500000。</p><p>输入例子:</p><p>3<br>2 3 5</p><p>输出例子:</p><p>5</p><p>个人思路：</p><h1 id="求一个数组中的最大相同相等子序列，判断并输出"><a href="#求一个数组中的最大相同相等子序列，判断并输出" class="headerlink" title="求一个数组中的最大相同相等子序列，判断并输出"></a>求一个数组中的最大相同相等子序列，判断并输出</h1><h1 id="1-数组总和-2-最大值"><a href="#1-数组总和-2-最大值" class="headerlink" title="1.数组总和 / 2 = 最大值"></a>1.数组总和 / 2 = 最大值</h1><h1 id="2-最大值-与-n1-n2-…-n-1"><a href="#2-最大值-与-n1-n2-…-n-1" class="headerlink" title="2.最大值 与 n1 + n2 + … + n-1"></a>2.最大值 与 n1 + n2 + … + n-1</h1><h1 id="if-gt-1"><a href="#if-gt-1" class="headerlink" title="if     &gt;       -1"></a>if &gt; -1</h1><h1 id="如果-lt"><a href="#如果-lt" class="headerlink" title="如果   &lt;"></a>如果 &lt;</h1><h1 id="最大值-次大值-与-n1-n2-…-n-2"><a href="#最大值-次大值-与-n1-n2-…-n-2" class="headerlink" title="最大值 + 次大值 与 n1 + n2 + … + n-2"></a>最大值 + 次大值 与 n1 + n2 + … + n-2</h1><h1 id="类推"><a href="#类推" class="headerlink" title="类推"></a>类推</h1><h1 id="有相等的-输出，无-1"><a href="#有相等的-输出，无-1" class="headerlink" title="有相等的 输出，无 -1"></a>有相等的 输出，无 -1</h1><p>通过率又是 30%，我就采取以上的大致思路，最大值，次大值，类推下去<br>正确答案(牛客网暂无)：</p><p>这题 python 解决的答案无，我就要举报牛客了，下面这里显示只有一个人，他答案还是不对的哟。</p><p>待大神解决。</p><p>12.<br>易老师购买了一盒饼干，盒子中一共有k块饼干，但是数字k有些数位变得模糊了，看不清楚数字具体是多少了。易老师需要你帮忙把这k块饼干平分给n个小朋友，易老师保证这盒饼干能平分给n个小朋友。现在你需要计算出k有多少种可能的数值<br>输入描述:</p><p>输入包括两行：</p><p>第一行为盒子上的数值k，模糊的数位用X表示，长度小于18(可能有多个模糊的数位)</p><p>第二行为小朋友的人数n</p><p>输出描述:</p><p>输出k可能的数值种数，保证至少为1</p><p>输入例子:</p><p>9999999999999X<br>3</p><p>输出例子:</p><p>4</p><p>个人思路：</p><h1 id="难度在于，输入的是数字还是字符串，如何分离"><a href="#难度在于，输入的是数字还是字符串，如何分离" class="headerlink" title="难度在于，输入的是数字还是字符串，如何分离"></a>难度在于，输入的是数字还是字符串，如何分离</h1><h1 id="999999X9999999X9999-类似这种情况"><a href="#999999X9999999X9999-类似这种情况" class="headerlink" title="999999X9999999X9999 类似这种情况"></a>999999X9999999X9999 类似这种情况</h1><h1 id="找-X-的位置，记录，确定有几位"><a href="#找-X-的位置，记录，确定有几位" class="headerlink" title="找 X 的位置，记录，确定有几位"></a>找 X 的位置，记录，确定有几位</h1><h1 id="依次分配，"><a href="#依次分配，" class="headerlink" title="依次分配，"></a>依次分配，</h1><h1 id="用不成-for-因为不知道有几重"><a href="#用不成-for-因为不知道有几重" class="headerlink" title="用不成 for,因为不知道有几重"></a>用不成 for,因为不知道有几重</h1><p>比如 X 出现 3 次，出现的下标为 3，5，6，我都可以记录下来。</p><p>问题在于现在我要生成 [‘0’, ‘0’, ‘0’] 到 [‘9’, ‘9’, ‘9’]的全部组合。卡在了这里。但是，这个思路是不对的，因为如果 X 太多，那么计算太费时了！<br>正确答案(牛客网 id：周昆)：</p><p>k = raw_input()</p><p>n = int(raw_input())</p><p>remainders = [1] + [0] * (n - 1)</p><p>for i, s in enumerate(k):</p><pre><code>temp = [0] * n

if s != &apos;X&apos;:

    s = int(s)

    for j in range(n):

        temp[(j*10+s) % n] += remainders[j]

else:

    for s in range(10):

        for j in range(n):

            temp[(j*10+s) % n] += remainders[j]

remainders = temp
</code></pre><p>print remainders[0]<br>这里说是用到状态转移方程，temp[(j*10+s) % n] += remainders[j] 是最关键的一句。望大家一起研究。</p><p>我觉得做这些题，都是需要将对应的问题转换成我们熟悉的代码，比如回溯，背包，动态规划，还有对数学的要求也不是盖的。</p><p>总之，理解题目，找好算法，理清逻辑，必要时写一个或几个功能函数，继续学习。</p></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><div></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>坚持学习技术，您的支持将鼓励我继续创作！</div> <button id="rewardButton" disable="enable" onclick='var qr=document.getElementById("QR");"none"===qr.style.display?qr.style.display="block":qr.style.display="none"'> <span>打赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"> <img id="wechat_qr" src="/images/wechatpay.jpg" alt="淘淘の后院 微信支付"><p>微信支付</p></div><div id="alipay" style="display:inline-block"> <img id="alipay_qr" src="/images/alipay.jpg" alt="淘淘の后院 支付宝"><p>支付宝</p></div><div id="bitcoin" style="display:inline-block"> <img id="bitcoin_qr" src="/images/bitcoin.png" alt="淘淘の后院 比特币"><p>比特币</p></div></div></div></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/2018/03/22/“我的博客”/" rel="prev" title="“我的博客”">“我的博客”<i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div><div class="comments" id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zNTEwNy8xMTY0Mg"></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div id="sidebar-dimmer"></div><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap"> 站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/uploads/001.png" alt="淘淘の后院"><p class="site-author-name" itemprop="name">淘淘の后院</p><p class="site-description motion-element" itemprop="description">->什么事都想做的人，其实什么事都不能做，而终归于失败。</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">6</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">2</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">4</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/mvp099" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:mvp_909@163.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i> E-Mail</a></span><span class="links-of-author-item"><a href="https://stackoverflow.com/yourname" target="_blank" title="StackOverflow"><i class="fa fa-fw fa-stack-overflow"></i> StackOverflow</a></span><span class="links-of-author-item"><a href="https://youtube.com/yourname" target="_blank" title="YouTube"><i class="fa fa-fw fa-youtube"></i> YouTube</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#这一段虽然可行，但是复杂度太高，AC-60"><span class="nav-number">1.</span> <span class="nav-text">这一段虽然可行，但是复杂度太高，AC 60%</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#b-append-i"><span class="nav-number">2.</span> <span class="nav-text">b.append(i)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#b-reverse"><span class="nav-number">3.</span> <span class="nav-text">b.reverse()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1、一个人只能做一项工程，而不能分饰两角；"><span class="nav-number">4.</span> <span class="nav-text">1、一个人只能做一项工程，而不能分饰两角；</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2、有几个工程师，每个工程师有一个工作即满足题意，不用6项工作全部都要有人做。"><span class="nav-number">5.</span> <span class="nav-text">2、有几个工程师，每个工程师有一个工作即满足题意，不用6项工作全部都要有人做。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#求一个数组中的最大相同相等子序列，判断并输出"><span class="nav-number">6.</span> <span class="nav-text">求一个数组中的最大相同相等子序列，判断并输出</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-数组总和-2-最大值"><span class="nav-number">7.</span> <span class="nav-text">1.数组总和 / 2 = 最大值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-最大值-与-n1-n2-…-n-1"><span class="nav-number">8.</span> <span class="nav-text">2.最大值 与 n1 + n2 + … + n-1</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#if-gt-1"><span class="nav-number">9.</span> <span class="nav-text">if &gt; -1</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#如果-lt"><span class="nav-number">10.</span> <span class="nav-text">如果 &lt;</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#最大值-次大值-与-n1-n2-…-n-2"><span class="nav-number">11.</span> <span class="nav-text">最大值 + 次大值 与 n1 + n2 + … + n-2</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类推"><span class="nav-number">12.</span> <span class="nav-text">类推</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#有相等的-输出，无-1"><span class="nav-number">13.</span> <span class="nav-text">有相等的 输出，无 -1</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#难度在于，输入的是数字还是字符串，如何分离"><span class="nav-number">14.</span> <span class="nav-text">难度在于，输入的是数字还是字符串，如何分离</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#999999X9999999X9999-类似这种情况"><span class="nav-number">15.</span> <span class="nav-text">999999X9999999X9999 类似这种情况</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#找-X-的位置，记录，确定有几位"><span class="nav-number">16.</span> <span class="nav-text">找 X 的位置，记录，确定有几位</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#依次分配，"><span class="nav-number">17.</span> <span class="nav-text">依次分配，</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#用不成-for-因为不知道有几重"><span class="nav-number">18.</span> <span class="nav-text">用不成 for,因为不知道有几重</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span><span class="with-love"><i class="fab fa-empire"></i></span> <span class="author" itemprop="copyrightHolder">淘淘の后院</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-area-chart"></i></span></div><div class="powered-by"><i class="fa fa-user-md"></i> <span id="busuanzi_container_site_uv">本站访客数:<span id="busuanzi_value_site_uv"></span></span></div><div class="theme-info"><div class="powered-by"></div> <span class="post-count">博客全站共33.1k字</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script type="text/javascript">!function(e,t){var n,c=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&((n=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",n.async=!0,c.parentNode.insertBefore(n,c))}(document,"script")</script></body></html><script type="text/javascript" src="/js/src/love.js"></script>