<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>未来已来|共享未来</title>
  
  <subtitle>喜欢自己</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mvp099.github.io/"/>
  <updated>2018-03-24T10:07:02.823Z</updated>
  <id>https://mvp099.github.io/</id>
  
  <author>
    <name>淘淘の后院</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在线教育平台模型草图</title>
    <link href="https://mvp099.github.io/2018/03/24/%E5%9C%A8%E7%BA%BF%E6%95%99%E8%82%B2%E5%B9%B3%E5%8F%B0%E6%A8%A1%E5%9E%8B%E8%8D%89%E5%9B%BE/"/>
    <id>https://mvp099.github.io/2018/03/24/在线教育平台模型草图/</id>
    <published>2018-03-24T10:03:59.000Z</published>
    <updated>2018-03-24T10:07:02.823Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/HBbg7zR.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/HBbg7zR.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="-Django2.0" scheme="https://mvp099.github.io/categories/Django2-0/"/>
    
    
      <category term="-Django" scheme="https://mvp099.github.io/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Python学习笔记000001</title>
    <link href="https://mvp099.github.io/2018/03/23/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0000001/"/>
    <id>https://mvp099.github.io/2018/03/23/Python学习笔记000001/</id>
    <published>2018-03-23T07:51:38.000Z</published>
    <updated>2018-03-23T08:04:26.751Z</updated>
    
    <content type="html"><![CDATA[<p>Python基础知识图表<a id="more"></a><br><img src="https://i.imgur.com/brCr8vA.png" alt=""><br><img src="https://i.imgur.com/bOdC1RR.png" alt=""><br><img src="https://i.imgur.com/EwQjh7r.png" alt=""><br><img src="https://i.imgur.com/TlBo7rB.png" alt=""><br><img src="https://i.imgur.com/HyeY3P0.png" alt=""><br><img src="https://i.imgur.com/pcqX5OK.png" alt=""><br><img src="https://i.imgur.com/F8CAsXk.png" alt=""><br><img src="https://i.imgur.com/LZY6Qqh.png" alt=""><br><img src="https://i.imgur.com/QNiE3u4.png" alt=""><br><img src="https://i.imgur.com/nKIgwP4.png" alt=""><br><img src="https://i.imgur.com/Rtoku4w.png" alt=""><br><img src="https://i.imgur.com/c9knK2w.png" alt=""><br><img src="https://i.imgur.com/xkC4yQG.png" alt=""><br><img src="https://i.imgur.com/CW7p435.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python基础知识图表
    
    </summary>
    
    
      <category term="-Python" scheme="https://mvp099.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Hello Python</title>
    <link href="https://mvp099.github.io/2018/03/23/hello/"/>
    <id>https://mvp099.github.io/2018/03/23/hello/</id>
    <published>2018-03-23T04:38:36.975Z</published>
    <updated>2018-03-26T23:26:30.809Z</updated>
    
    <content type="html"><![CDATA[<p>#程序的基本编写方法：</p><p>##IPO模式</p><h4 id="I-Input-输入，即程序的输入"><a href="#I-Input-输入，即程序的输入" class="headerlink" title="I:Input 输入，即程序的输入"></a>I:Input 输入，即程序的输入</h4><h4 id="P-Process-处理，即程序的主要逻辑"><a href="#P-Process-处理，即程序的主要逻辑" class="headerlink" title="P:Process 处理，即程序的主要逻辑"></a>P:Process 处理，即程序的主要逻辑</h4><h4 id="O-Output-输出，程序的输出"><a href="#O-Output-输出，程序的输出" class="headerlink" title="O:Output 输出，程序的输出"></a>O:Output 输出，程序的输出</h4><p><img src="https://i.imgur.com/gHHSYCz.png" alt=""><br><img src="https://i.imgur.com/QQPveoO.png" alt=""><img src="https://i.imgur.com/f9R0PED.png" alt=""><br><img src="https://i.imgur.com/n59AXYL.png" alt=""><img src="https://i.imgur.com/nIp8nuI.png" alt=""><br><img src="https://i.imgur.com/oELCuMT.png" alt=""><img src="https://i.imgur.com/ki12U7h.png" alt=""><br><img src="https://i.imgur.com/CUNzWYt.png" alt=""><img src="https://i.imgur.com/plt3zEL.png" alt=""><br><img src="https://i.imgur.com/PaaHeND.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#程序的基本编写方法：&lt;/p&gt;
&lt;p&gt;##IPO模式&lt;/p&gt;
&lt;h4 id=&quot;I-Input-输入，即程序的输入&quot;&gt;&lt;a href=&quot;#I-Input-输入，即程序的输入&quot; class=&quot;headerlink&quot; title=&quot;I:Input 输入，即程序的输入&quot;&gt;&lt;/a&gt;I
      
    
    </summary>
    
      <category term="-python" scheme="https://mvp099.github.io/categories/python/"/>
    
    
      <category term="-python3.6" scheme="https://mvp099.github.io/tags/python3-6/"/>
    
  </entry>
  
  <entry>
    <title>first</title>
    <link href="https://mvp099.github.io/2018/03/23/first/"/>
    <id>https://mvp099.github.io/2018/03/23/first/</id>
    <published>2018-03-22T16:49:15.000Z</published>
    <updated>2018-03-26T23:23:16.995Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/GnSZkv7.jpg" alt=""><br><!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-generate-toc again --><br><strong>Table of Contents</strong></p><ul><li><a href="#python语言特性">Python语言特性</a><ul><li><a href="#1-python的函数参数传递">1 Python的函数参数传递</a></li><li><a href="#2-python中的元类metaclass">2 Python中的元类(metaclass)</a></li><li><a href="#3-staticmethod和classmethod">3 @staticmethod和@classmethod</a></li><li><a href="#4-类变量和实例变量">4 类变量和实例变量</a></li><li><a href="#5-python自省">5 Python自省</a></li><li><a href="#6-字典推导式">6 字典推导式</a></li><li><a href="#7-python中单下划线和双下划线">7 Python中单下划线和双下划线</a></li><li><a href="#8-字符串格式化和format">8 字符串格式化:\x和.format</a></li><li><a href="#9-迭代器和生成器">9 迭代器和生成器</a></li><li><a href="#10-args-and-kwargs">10 *args and <code>**kwargs</code></a></li><li><a href="#11-面向切面编程aop和装饰器">11 面向切面编程AOP和装饰器</a></li><li><a href="#12-鸭子类型">12 鸭子类型</a></li><li><a href="#13-python中重载">13 Python中重载</a></li><li><a href="#14-新式类和旧式类">14 新式类和旧式类</a></li><li><a href="#15-__new__和__init__的区别">15 <strong>new</strong>和<code><strong>init</strong></code>的区别</a></li><li><a href="#16-单例模式">16 单例模式</a><ul><li><a href="#1-使用__new__方法">1 使用<strong>new</strong>方法</a></li><li><a href="#2-共享属性">2 共享属性</a></li><li><a href="#3-装饰器版本">3 装饰器版本</a></li><li><a href="#4-import方法">4 import方法</a></li></ul></li><li><a href="#17-python中的作用域">17 Python中的作用域</a></li><li><a href="#18-gil线程全局锁">18 GIL线程全局锁</a></li><li><a href="#19-协程">19 协程</a></li><li><a href="#20-闭包">20 闭包</a></li><li><a href="#21-lambda函数">21 lambda函数</a></li><li><a href="#22-python函数式编程">22 Python函数式编程</a></li><li><a href="#23-python里的拷贝">23 Python里的拷贝</a></li><li><a href="#24-python垃圾回收机制">24 Python垃圾回收机制</a><ul><li><a href="#1-引用计数">1 引用计数</a></li><li><a href="#2-标记-清除机制">2 标记-清除机制</a></li><li><a href="#3-分代技术">3 分代技术</a></li></ul></li><li><a href="#25-python的list">25 Python的List</a></li><li><a href="#26-python的is">26 Python的is</a></li><li><a href="#27-readreadline和readlines">27 read,readline和readlines</a></li><li><a href="#28-python2和3的区别">28 Python2和3的区别</a></li><li><a href="#29-super-init">29 super init</a></li><li><a href="#30-range-and-xrange">30 range and xrange</a></li></ul></li><li><a href="#操作系统">操作系统</a><ul><li><a href="#1-selectpoll和epoll">1 select,poll和epoll</a></li><li><a href="#2-调度算法">2 调度算法</a></li><li><a href="#3-死锁">3 死锁</a></li><li><a href="#4-程序编译与链接">4 程序编译与链接</a><ul><li><a href="#1-预处理">1 预处理</a></li><li><a href="#2-编译">2 编译</a></li><li><a href="#3-汇编">3 汇编</a></li><li><a href="#4-链接">4 链接</a></li></ul></li><li><a href="#5-静态链接和动态链接">5 静态链接和动态链接</a></li><li><a href="#6-虚拟内存技术">6 虚拟内存技术</a></li><li><a href="#7-分页和分段">7 分页和分段</a><ul><li><a href="#分页与分段的主要区别">分页与分段的主要区别</a></li></ul></li><li><a href="#8-页面置换算法">8 页面置换算法</a></li><li><a href="#9-边沿触发和水平触发">9 边沿触发和水平触发</a></li></ul></li><li><a href="#数据库">数据库</a><ul><li><a href="#1-事务">1 事务</a></li><li><a href="#2-数据库索引">2 数据库索引</a></li><li><a href="#3-redis原理">3 Redis原理</a><ul><li><a href="#redis是什么">Redis是什么？</a></li><li><a href="#redis数据库">Redis数据库</a></li><li><a href="#redis缺点">Redis缺点</a></li></ul></li><li><a href="#4-乐观锁和悲观锁">4 乐观锁和悲观锁</a></li><li><a href="#5-mvcc">5 MVCC</a><ul><li><a href="#mysql的innodb引擎是如何实现mvcc的"><a href="http://lib.csdn.net/base/mysql" target="_blank" rel="noopener">MySQL</a>的innodb引擎是如何实现MVCC的</a></li></ul></li><li><a href="#6-myisam和innodb">6 MyISAM和InnoDB</a></li></ul></li><li><a href="#网络">网络</a><ul><li><a href="#1-三次握手">1 三次握手</a></li><li><a href="#2-四次挥手">2 四次挥手</a></li><li><a href="#3-arp协议">3 ARP协议</a></li><li><a href="#4-urllib和urllib2的区别">4 urllib和urllib2的区别</a></li><li><a href="#5-post和get">5 Post和Get</a></li><li><a href="#6-cookie和session">6 Cookie和Session</a></li><li><a href="#7-apache和nginx的区别">7 apache和nginx的区别</a></li><li><a href="#8-网站用户密码保存">8 网站用户密码保存</a></li><li><a href="#9-http和https">9 HTTP和HTTPS</a></li><li><a href="#10-xsrf和xss">10 XSRF和XSS</a></li><li><a href="#11-幂等-idempotence">11 幂等 Idempotence</a></li><li><a href="#12-restful架构soaprpc">12 RESTful架构(SOAP,RPC)</a></li><li><a href="#13-soap">13 SOAP</a></li><li><a href="#14-rpc">14 RPC</a></li><li><a href="#15-cgi和wsgi">15 CGI和WSGI</a></li><li><a href="#16-中间人攻击">16 中间人攻击</a></li><li><a href="#17-c10k问题">17 c10k问题</a></li><li><a href="#18-socket">18 socket</a></li><li><a href="#19-浏览器缓存">19 浏览器缓存</a></li><li><a href="#20-http10和http11">20 HTTP1.0和HTTP1.1</a></li><li><a href="#21-ajax">21 Ajax</a></li></ul></li><li><a href="#nix">*NIX</a><ul><li><a href="#unix进程间通信方式ipc">unix进程间通信方式(IPC)</a></li></ul></li><li><a href="#数据结构">数据结构</a><ul><li><a href="#1-红黑树">1 红黑树</a></li></ul></li><li><a href="#编程题">编程题</a><ul><li><a href="#1-台阶问题斐波那契">1 台阶问题/斐波那契</a></li><li><a href="#2-变态台阶问题">2 变态台阶问题</a></li><li><a href="#3-矩形覆盖">3 矩形覆盖</a></li><li><a href="#4-杨氏矩阵查找">4 杨氏矩阵查找</a></li><li><a href="#5-去除列表中的重复元素">5 去除列表中的重复元素</a></li><li><a href="#6-链表成对调换">6 链表成对调换</a></li><li><a href="#7-创建字典的方法">7 创建字典的方法</a><ul><li><a href="#1-直接创建">1 直接创建</a></li><li><a href="#2-工厂方法">2 工厂方法</a></li><li><a href="#3-fromkeys方法">3 fromkeys()方法</a></li></ul></li><li><a href="#8-合并两个有序列表">8 合并两个有序列表</a></li><li><a href="#9-交叉链表求交点">9 交叉链表求交点</a></li><li><a href="#10-二分查找">10 二分查找</a></li><li><a href="#11-快排">11 快排</a></li><li><a href="#12-找零问题">12 找零问题</a></li><li><a href="#13-广度遍历和深度遍历二叉树">13 广度遍历和深度遍历二叉树</a></li><li><a href="#17-前中后序遍历">17 前中后序遍历</a></li><li><a href="#18-求最大树深">18 求最大树深</a></li><li><a href="#19-求两棵树是否相同">19 求两棵树是否相同</a></li><li><a href="#20-前序中序求后序">20 前序中序求后序</a></li><li><a href="#21-单链表逆置">21 单链表逆置</a></li><li><a href="#22-两个字符串是否是变位词">22 两个字符串是否是变位词</a></li><li><a href="#23-动态规划问题">23 动态规划问题</a></li></ul></li></ul><!-- markdown-toc end --><h1 id="Python语言特性"><a href="#Python语言特性" class="headerlink" title="Python语言特性"></a>Python语言特性</h1><h2 id="1-Python的函数参数传递"><a href="#1-Python的函数参数传递" class="headerlink" title="1 Python的函数参数传递"></a>1 Python的函数参数传递</h2><p>看两个例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(a)</span>:</span></span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">fun(a)</span><br><span class="line"><span class="keyword">print</span> a  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(a)</span>:</span></span><br><span class="line">    a.append(<span class="number">1</span>)</span><br><span class="line">fun(a)</span><br><span class="line"><span class="keyword">print</span> a  <span class="comment"># [1]</span></span><br></pre></td></tr></table></figure><p>所有的变量都可以理解是内存中一个对象的“引用”，或者，也可以看似c中void*的感觉。</p><p>通过<code>id</code>来看引用<code>a</code>的内存地址可以比较理解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"func_in"</span>,id(a)   <span class="comment"># func_in 41322472</span></span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"re-point"</span>,id(a), id(<span class="number">2</span>)   <span class="comment"># re-point 41322448 41322448</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"func_out"</span>,id(a), id(<span class="number">1</span>)  <span class="comment"># func_out 41322472 41322472</span></span><br><span class="line">fun(a)</span><br><span class="line"><span class="keyword">print</span> a  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure><p>注：具体的值在不同电脑上运行时可能不同。</p><p>可以看到，在执行完<code>a = 2</code>之后，<code>a</code>引用中保存的值，即内存地址发生变化，由原来<code>1</code>对象的所在的地址变成了<code>2</code>这个实体对象的内存地址。</p><p>而第2个例子<code>a</code>引用保存的内存值就不会发生变化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"func_in"</span>,id(a)  <span class="comment"># func_in 53629256</span></span><br><span class="line">    a.append(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"func_out"</span>,id(a)     <span class="comment"># func_out 53629256</span></span><br><span class="line">fun(a)</span><br><span class="line"><span class="keyword">print</span> a  <span class="comment"># [1]</span></span><br></pre></td></tr></table></figure><p>这里记住的是类型是属于对象的，而不是变量。而对象有两种,“可更改”（mutable）与“不可更改”（immutable）对象。在python中，strings, tuples, 和numbers是不可更改的对象，而 list, dict, set 等则是可以修改的对象。(这就是这个问题的重点)</p><p>当一个引用传递给函数的时候,函数自动复制一份引用,这个函数里的引用和外边的引用没有半毛关系了.所以第一个例子里函数把引用指向了一个不可变对象,当函数返回的时候,外面的引用没半毛感觉.而第二个例子就不一样了,函数内的引用指向的是可变对象,对它的操作就和定位了指针地址一样,在内存里进行修改.</p><p>如果还不明白的话,这里有更好的解释: <a href="http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference" target="_blank" rel="noopener">http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference</a></p><h2 id="2-Python中的元类-metaclass"><a href="#2-Python中的元类-metaclass" class="headerlink" title="2 Python中的元类(metaclass)"></a>2 Python中的元类(metaclass)</h2><p>这个非常的不常用,但是像ORM这种复杂的结构还是会需要的,详情请看:<a href="http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python" target="_blank" rel="noopener">http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python</a></p><h2 id="3-staticmethod和-classmethod"><a href="#3-staticmethod和-classmethod" class="headerlink" title="3 @staticmethod和@classmethod"></a>3 @staticmethod和@classmethod</h2><p>Python其实有3个方法,即静态方法(staticmethod),类方法(classmethod)和实例方法,如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"executing foo(%s)"</span>%(x)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"executing foo(%s,%s)"</span>%(self,x)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_foo</span><span class="params">(cls,x)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"executing class_foo(%s,%s)"</span>%(cls,x)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static_foo</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"executing static_foo(%s)"</span>%x</span><br><span class="line"></span><br><span class="line">a=A()</span><br></pre></td></tr></table></figure><p>这里先理解下函数参数里面的self和cls.这个self和cls是对类或者实例的绑定,对于一般的函数来说我们可以这么调用<code>foo(x)</code>,这个函数就是最常用的,它的工作跟任何东西(类,实例)无关.对于实例方法,我们知道在类里每次定义方法的时候都需要绑定这个实例,就是<code>foo(self, x)</code>,为什么要这么做呢?因为实例方法的调用离不开实例,我们需要把实例自己传给函数,调用的时候是这样的<code>a.foo(x)</code>(其实是<code>foo(a, x)</code>).类方法一样,只不过它传递的是类而不是实例,<code>A.class_foo(x)</code>.注意这里的self和cls可以替换别的参数,但是python的约定是这俩,还是不要改的好.</p><p>对于静态方法其实和普通的方法一样,不需要对谁进行绑定,唯一的区别是调用的时候需要使用<code>a.static_foo(x)</code>或者<code>A.static_foo(x)</code>来调用.</p><table><thead><tr><th style="text-align:left">\</th><th style="text-align:left">实例方法</th><th style="text-align:left">类方法</th><th style="text-align:left">静态方法</th></tr></thead><tbody><tr><td style="text-align:left">a = A()</td><td style="text-align:left">a.foo(x)</td><td style="text-align:left">a.class_foo(x)</td><td style="text-align:left">a.static_foo(x)</td></tr><tr><td style="text-align:left">A</td><td style="text-align:left">不可用</td><td style="text-align:left">A.class_foo(x)</td><td style="text-align:left">A.static_foo(x)</td></tr></tbody></table><p>更多关于这个问题:</p><ol><li><a href="http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python" target="_blank" rel="noopener">http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python</a></li><li><a href="https://realpython.com/blog/python/instance-class-and-static-methods-demystified/" target="_blank" rel="noopener">https://realpython.com/blog/python/instance-class-and-static-methods-demystified/</a><h2 id="4-类变量和实例变量"><a href="#4-类变量和实例变量" class="headerlink" title="4 类变量和实例变量"></a>4 类变量和实例变量</h2></li></ol><p><strong>类变量：</strong></p><blockquote><p>​    是可在类的所有实例之间共享的值（也就是说，它们不是单独分配给每个实例的）。例如下例中，num_of_instance 就是类变量，用于跟踪存在着多少个Test 的实例。</p></blockquote><p><strong>实例变量：</strong></p><blockquote><p>实例化之后，每个实例单独拥有的变量。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    num_of_instance = <span class="number">0</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span>  </span><br><span class="line">        self.name = name  </span><br><span class="line">        Test.num_of_instance += <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  </span><br><span class="line">    <span class="keyword">print</span> Test.num_of_instance   <span class="comment"># 0</span></span><br><span class="line">    t1 = Test(<span class="string">'jack'</span>)  </span><br><span class="line">    <span class="keyword">print</span> Test.num_of_instance   <span class="comment"># 1</span></span><br><span class="line">    t2 = Test(<span class="string">'lucy'</span>)  </span><br><span class="line">    <span class="keyword">print</span> t1.name , t1.num_of_instance  <span class="comment"># jack 2</span></span><br><span class="line">    <span class="keyword">print</span> t2.name , t2.num_of_instance  <span class="comment"># lucy 2</span></span><br></pre></td></tr></table></figure><blockquote><p>补充的例子</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    name=<span class="string">"aaa"</span></span><br><span class="line"></span><br><span class="line">p1=Person()</span><br><span class="line">p2=Person()</span><br><span class="line">p1.name=<span class="string">"bbb"</span></span><br><span class="line"><span class="keyword">print</span> p1.name  <span class="comment"># bbb</span></span><br><span class="line"><span class="keyword">print</span> p2.name  <span class="comment"># aaa</span></span><br><span class="line"><span class="keyword">print</span> Person.name  <span class="comment"># aaa</span></span><br></pre></td></tr></table></figure><p>这里<code>p1.name=&quot;bbb&quot;</code>是实例调用了类变量,这其实和上面第一个问题一样,就是函数传参的问题,<code>p1.name</code>一开始是指向的类变量<code>name=&quot;aaa&quot;</code>,但是在实例的作用域里把类变量的引用改变了,就变成了一个实例变量,self.name不再引用Person的类变量name了.</p><p>可以看看下面的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    name=[]</span><br><span class="line"></span><br><span class="line">p1=Person()</span><br><span class="line">p2=Person()</span><br><span class="line">p1.name.append(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span> p1.name  <span class="comment"># [1]</span></span><br><span class="line"><span class="keyword">print</span> p2.name  <span class="comment"># [1]</span></span><br><span class="line"><span class="keyword">print</span> Person.name  <span class="comment"># [1]</span></span><br></pre></td></tr></table></figure><p>参考:<a href="http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block" target="_blank" rel="noopener">http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block</a></p><h2 id="5-Python自省"><a href="#5-Python自省" class="headerlink" title="5 Python自省"></a>5 Python自省</h2><p>这个也是python彪悍的特性.</p><p>自省就是面向对象的语言所写的程序在运行时,所能知道对象的类型.简单一句就是运行时能够获得对象的类型.比如type(),dir(),getattr(),hasattr(),isinstance().</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = &#123;<span class="string">'a'</span>:<span class="number">1</span>,<span class="string">'b'</span>:<span class="number">2</span>,<span class="string">'c'</span>:<span class="number">3</span>&#125;</span><br><span class="line">c = <span class="keyword">True</span></span><br><span class="line"><span class="keyword">print</span> type(a),type(b),type(c) <span class="comment"># &lt;type 'list'&gt; &lt;type 'dict'&gt; &lt;type 'bool'&gt;</span></span><br><span class="line"><span class="keyword">print</span> isinstance(a,list)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h2 id="6-字典推导式"><a href="#6-字典推导式" class="headerlink" title="6 字典推导式"></a>6 字典推导式</h2><p>可能你见过列表推导时,却没有见过字典推导式,在2.7中才加入的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;key: value <span class="keyword">for</span> (key, value) <span class="keyword">in</span> iterable&#125;</span><br></pre></td></tr></table></figure><h2 id="7-Python中单下划线和双下划线"><a href="#7-Python中单下划线和双下划线" class="headerlink" title="7 Python中单下划线和双下划线"></a>7 Python中单下划线和双下划线</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>            self.__superprivate = <span class="string">"Hello"</span></span><br><span class="line"><span class="meta">... </span>            self._semiprivate = <span class="string">", world!"</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mc = MyClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> mc.__superprivate</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: myClass instance has no attribute <span class="string">'__superprivate'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> mc._semiprivate</span><br><span class="line">, world!</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> mc.__dict__</span><br><span class="line">&#123;<span class="string">'_MyClass__superprivate'</span>: <span class="string">'Hello'</span>, <span class="string">'_semiprivate'</span>: <span class="string">', world!'</span>&#125;</span><br></pre></td></tr></table></figure><p><code>__foo__</code>:一种约定,Python内部的名字,用来区别其他用户自定义的命名,以防冲突，就是例如<code>__init__()</code>,<code>__del__()</code>,<code>__call__()</code>这些特殊方法</p><p><code>_foo</code>:一种约定,用来指定变量私有.程序员用来指定私有变量的一种方式.不能用from module import * 导入，其他方面和公有一样访问；</p><p><code>__foo</code>:这个有真正的意义:解析器用<code>_classname__foo</code>来代替这个名字,以区别和其他类相同的命名,它无法直接像公有成员一样随便访问,通过对象名._类名__xxx这样的方式可以访问.</p><p>详情见:<a href="http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python" target="_blank" rel="noopener">http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python</a></p><p>或者: <a href="http://www.zhihu.com/question/19754941" target="_blank" rel="noopener">http://www.zhihu.com/question/19754941</a></p><h2 id="8-字符串格式化-和-format"><a href="#8-字符串格式化-和-format" class="headerlink" title="8 字符串格式化:%和.format"></a>8 字符串格式化:%和.format</h2><p>.format在许多方面看起来更便利.对于<code>%</code>最烦人的是它无法同时传递一个变量和元组.你可能会想下面的代码不会有什么问题:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"hi there %s"</span> % <span class="built_in">name</span></span><br></pre></td></tr></table></figure><p>但是,如果name恰好是(1,2,3),它将会抛出一个TypeError异常.为了保证它总是正确的,你必须这样做:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"hi there %s"</span> % (<span class="built_in">name</span>,)   <span class="comment"># 提供一个单元素的数组而不是一个参数</span></span><br></pre></td></tr></table></figure><p>但是有点丑..format就没有这些问题.你给的第二个问题也是这样,.format好看多了.</p><p>你为什么不用它?</p><ul><li>不知道它(在读这个之前)</li><li>为了和Python2.5兼容(譬如logging库建议使用<code>%</code>(<a href="https://github.com/taizilongxu/interview_python/issues/4" target="_blank" rel="noopener">issue #4</a>))</li></ul><p><a href="http://stackoverflow.com/questions/5082452/python-string-formatting-vs-format" target="_blank" rel="noopener">http://stackoverflow.com/questions/5082452/python-string-formatting-vs-format</a></p><h2 id="9-迭代器和生成器"><a href="#9-迭代器和生成器" class="headerlink" title="9 迭代器和生成器"></a>9 迭代器和生成器</h2><p>这个是stackoverflow里python排名第一的问题,值得一看: <a href="http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python" target="_blank" rel="noopener">http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python</a></p><p>这是中文版: <a href="http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/1/README.html" target="_blank" rel="noopener">http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/1/README.html</a></p><p>这里有个关于生成器的创建问题面试官有考：<br>问：  将列表生成式中[]改成() 之后数据结构是否改变？<br>答案：是，从列表变为生成器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = (x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x0000028F8B774200</span>&gt;</span><br></pre></td></tr></table></figure><p>通过列表生成式，可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含百万元素的列表，不仅是占用很大的内存空间，如：我们只需要访问前面的几个元素，后面大部分元素所占的空间都是浪费的。因此，没有必要创建完整的列表（节省大量内存空间）。在Python中，我们可以采用生成器：边循环，边计算的机制—&gt;generator</p><h2 id="10-args-and-kwargs"><a href="#10-args-and-kwargs" class="headerlink" title="10 *args and **kwargs"></a>10 <code>*args</code> and <code>**kwargs</code></h2><p>用<code>*args</code>和<code>**kwargs</code>只是为了方便并没有强制使用它们.</p><p>当你不确定你的函数里将要传递多少参数时你可以用<code>*args</code>.例如,它可以传递任意数量的参数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">print_everything</span><span class="params">(*args)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> count, thing <span class="keyword">in</span> enumerate(args):</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">print</span> <span class="string">'&#123;0&#125;. &#123;1&#125;'</span>.format(count, thing)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_everything(<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'cabbage'</span>)</span><br><span class="line"><span class="number">0.</span> apple</span><br><span class="line"><span class="number">1.</span> banana</span><br><span class="line"><span class="number">2.</span> cabbage</span><br></pre></td></tr></table></figure><p>相似的,<code>**kwargs</code>允许你使用没有事先定义的参数名:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">table_things</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> name, value <span class="keyword">in</span> kwargs.items():</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">print</span> <span class="string">'&#123;0&#125; = &#123;1&#125;'</span>.format(name, value)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>table_things(apple = <span class="string">'fruit'</span>, cabbage = <span class="string">'vegetable'</span>)</span><br><span class="line">cabbage = vegetable</span><br><span class="line">apple = fruit</span><br></pre></td></tr></table></figure><p>你也可以混着用.命名参数首先获得参数值然后所有的其他参数都传递给<code>*args</code>和<code>**kwargs</code>.命名参数在列表的最前端.例如:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">table_things</span><span class="params">(titlestring, **kwargs)</span></span></span><br></pre></td></tr></table></figure><p><code>*args</code>和<code>**kwargs</code>可以同时在函数的定义中,但是<code>*args</code>必须在<code>**kwargs</code>前面.</p><p>当调用函数时你也可以用<code>*</code>和<code>**</code>语法.例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">print_three_things</span><span class="params">(a, b, c)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">'a = &#123;0&#125;, b = &#123;1&#125;, c = &#123;2&#125;'</span>.format(a,b,c)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mylist = [<span class="string">'aardvark'</span>, <span class="string">'baboon'</span>, <span class="string">'cat'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_three_things(*mylist)</span><br><span class="line"></span><br><span class="line">a = aardvark, b = baboon, c = cat</span><br></pre></td></tr></table></figure><p>就像你看到的一样,它可以传递列表(或者元组)的每一项并把它们解包.注意必须与它们在函数里的参数相吻合.当然,你也可以在函数定义或者函数调用时用*.</p><p><a href="http://stackoverflow.com/questions/3394835/args-and-kwargs" target="_blank" rel="noopener">http://stackoverflow.com/questions/3394835/args-and-kwargs</a></p><h2 id="11-面向切面编程AOP和装饰器"><a href="#11-面向切面编程AOP和装饰器" class="headerlink" title="11 面向切面编程AOP和装饰器"></a>11 面向切面编程AOP和装饰器</h2><p>这个AOP一听起来有点懵,同学面阿里的时候就被问懵了…</p><p>装饰器是一个很著名的设计模式，经常被用于有切面需求的场景，较为经典的有插入日志、性能测试、事务处理等。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量函数中与函数功能本身无关的雷同代码并继续重用。概括的讲，<strong>装饰器的作用就是为已经存在的对象添加额外的功能。</strong></p><p>这个问题比较大,推荐: <a href="http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python" target="_blank" rel="noopener">http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python</a></p><p>中文: <a href="http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/3/README.html" target="_blank" rel="noopener">http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/3/README.html</a></p><h2 id="12-鸭子类型"><a href="#12-鸭子类型" class="headerlink" title="12 鸭子类型"></a>12 鸭子类型</h2><p>“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”</p><p>我们并不关心对象是什么类型，到底是不是鸭子，只关心行为。</p><p>比如在python中，有很多file-like的东西，比如StringIO,GzipFile,socket。它们有很多相同的方法，我们把它们当作文件使用。</p><p>又比如list.extend()方法中,我们并不关心它的参数是不是list,只要它是可迭代的,所以它的参数可以是list/tuple/dict/字符串/生成器等.</p><p>鸭子类型在动态语言中经常使用，非常灵活，使得python不想java那样专门去弄一大堆的设计模式。</p><h2 id="13-Python中重载"><a href="#13-Python中重载" class="headerlink" title="13 Python中重载"></a>13 Python中重载</h2><p>引自知乎:<a href="http://www.zhihu.com/question/20053359" target="_blank" rel="noopener">http://www.zhihu.com/question/20053359</a></p><p>函数重载主要是为了解决两个问题。</p><ol><li>可变参数类型。</li><li>可变参数个数。</li></ol><p>另外，一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载，如果两个函数的功能其实不同，那么不应当使用重载，而应当使用一个名字不同的函数。</p><p>好吧，那么对于情况 1 ，函数功能相同，但是参数类型不同，python 如何处理？答案是根本不需要处理，因为 python 可以接受任何类型的参数，如果函数的功能相同，那么不同的参数类型在 python 中很可能是相同的代码，没有必要做成两个不同函数。</p><p>那么对于情况 2 ，函数功能相同，但参数个数不同，python 如何处理？大家知道，答案就是缺省参数。对那些缺少的参数设定为缺省参数即可解决问题。因为你假设函数功能相同，那么那些缺少的参数终归是需要用的。</p><p>好了，鉴于情况 1 跟 情况 2 都有了解决方案，python 自然就不需要函数重载了。</p><h2 id="14-新式类和旧式类"><a href="#14-新式类和旧式类" class="headerlink" title="14 新式类和旧式类"></a>14 新式类和旧式类</h2><p>这个面试官问了,我说了老半天,不知道他问的真正意图是什么.</p><p><a href="http://stackoverflow.com/questions/54867/what-is-the-difference-between-old-style-and-new-style-classes-in-python" target="_blank" rel="noopener">stackoverflow</a></p><p>这篇文章很好的介绍了新式类的特性: <a href="http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html" target="_blank" rel="noopener">http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html</a></p><p>新式类很早在2.2就出现了,所以旧式类完全是兼容的问题,Python3里的类全部都是新式类.这里有一个MRO问题可以了解下(新式类是广度优先,旧式类是深度优先),&lt;Python核心编程&gt;里讲的也很多.</p><blockquote><p>一个旧式类的深度优先的例子</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo1</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"A"</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo2</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo1</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"C"</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B, C)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">d = D()</span><br><span class="line">d.foo1()</span><br><span class="line"></span><br><span class="line"><span class="comment"># A</span></span><br></pre></td></tr></table></figure><p><strong>按照经典类的查找顺序<code>从左到右深度优先</code>的规则，在访问<code>d.foo1()</code>的时候,D这个类是没有的..那么往上查找,先找到B,里面没有,深度优先,访问A,找到了foo1(),所以这时候调用的是A的foo1()，从而导致C重写的foo1()被绕过</strong></p><h2 id="15-new-和-init-的区别"><a href="#15-new-和-init-的区别" class="headerlink" title="15 __new__和__init__的区别"></a>15 <code>__new__</code>和<code>__init__</code>的区别</h2><p>这个<code>__new__</code>确实很少见到,先做了解吧.</p><ol><li><code>__new__</code>是一个静态方法,而<code>__init__</code>是一个实例方法.</li><li><code>__new__</code>方法会返回一个创建的实例,而<code>__init__</code>什么都不返回.</li><li>只有在<code>__new__</code>返回一个cls的实例时后面的<code>__init__</code>才能被调用.</li><li>当创建一个新实例时调用<code>__new__</code>,初始化一个实例时用<code>__init__</code>.</li></ol><p><a href="http://stackoverflow.com/questions/674304/pythons-use-of-new-and-init" target="_blank" rel="noopener">stackoverflow</a></p><p>ps: <code>__metaclass__</code>是创建类时起作用.所以我们可以分别使用<code>__metaclass__</code>,<code>__new__</code>和<code>__init__</code>来分别在类创建,实例创建和实例初始化的时候做一些小手脚.</p><h2 id="16-单例模式"><a href="#16-单例模式" class="headerlink" title="16 单例模式"></a>16 单例模式</h2><blockquote><p>​    单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例类的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。</p><p><code>__new__()</code>在<code>__init__()</code>之前被调用，用于生成实例对象。利用这个方法和类的属性的特点可以实现设计模式的单例模式。单例模式是指创建唯一对象，单例模式设计的类只能实例<br><strong>这个绝对常考啊.绝对要记住1~2个方法,当时面试官是让手写的.</strong></p></blockquote><h3 id="1-使用-new-方法"><a href="#1-使用-new-方法" class="headerlink" title="1 使用__new__方法"></a>1 使用<code>__new__</code>方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">'_instance'</span>):</span><br><span class="line">            orig = super(Singleton, cls)</span><br><span class="line">            cls._instance = orig.__new__(cls, *args, **kw)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(Singleton)</span>:</span></span><br><span class="line">    a = <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="2-共享属性"><a href="#2-共享属性" class="headerlink" title="2 共享属性"></a>2 共享属性</h3><p>创建实例时把所有实例的<code>__dict__</code>指向同一个字典,这样它们具有相同的属性和方法.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Borg</span><span class="params">(object)</span>:</span></span><br><span class="line">    _state = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">        ob = super(Borg, cls).__new__(cls, *args, **kw)</span><br><span class="line">        ob.__dict__ = cls._state</span><br><span class="line">        <span class="keyword">return</span> ob</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass2</span><span class="params">(Borg)</span>:</span></span><br><span class="line">    a = <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="3-装饰器版本"><a href="#3-装饰器版本" class="headerlink" title="3 装饰器版本"></a>3 装饰器版本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">    instances = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getinstance</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">            instances[cls] = cls(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> instances[cls]</span><br><span class="line">    <span class="keyword">return</span> getinstance</span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h3 id="4-import方法"><a href="#4-import方法" class="headerlink" title="4 import方法"></a>4 import方法</h3><p>作为python的模块是天然的单例模式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysingleton.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">My_Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">my_singleton = My_Singleton()</span><br><span class="line"></span><br><span class="line"><span class="comment"># to use</span></span><br><span class="line"><span class="keyword">from</span> mysingleton <span class="keyword">import</span> my_singleton</span><br><span class="line"></span><br><span class="line">my_singleton.foo()</span><br></pre></td></tr></table></figure><p><strong><a href="http://python.jobbole.com/87294/" target="_blank" rel="noopener">单例模式伯乐在线详细解释</a></strong></p><h2 id="17-Python中的作用域"><a href="#17-Python中的作用域" class="headerlink" title="17 Python中的作用域"></a>17 Python中的作用域</h2><p>Python 中，一个变量的作用域总是由在代码中被赋值的地方所决定的。</p><p>当 Python 遇到一个变量的话他会按照这样的顺序进行搜索：</p><p>本地作用域（Local）→当前作用域被嵌入的本地作用域（Enclosing locals）→全局/模块作用域（Global）→内置作用域（Built-in）</p><h2 id="18-GIL线程全局锁"><a href="#18-GIL线程全局锁" class="headerlink" title="18 GIL线程全局锁"></a>18 GIL线程全局锁</h2><p>线程全局锁(Global Interpreter Lock),即Python为了保证线程安全而采取的独立线程运行的限制,说白了就是一个核只能在同一时间运行一个线程.<strong>对于io密集型任务，python的多线程起到作用，但对于cpu密集型任务，python的多线程几乎占不到任何优势，还有可能因为争夺资源而变慢。</strong></p><p>见<a href="http://www.oschina.net/translate/pythons-hardest-problem" target="_blank" rel="noopener">Python 最难的问题</a></p><p>解决办法就是多进程和下面的协程(协程也只是单CPU,但是能减小切换代价提升性能).</p><h2 id="19-协程"><a href="#19-协程" class="headerlink" title="19 协程"></a>19 协程</h2><p>知乎被问到了,呵呵哒,跪了</p><p>简单点说协程是进程和线程的升级版,进程和线程都面临着内核态和用户态的切换问题而耗费许多切换时间,而协程就是用户自己控制切换的时机,不再需要陷入系统的内核态.</p><p>Python里最常见的yield就是协程的思想!可以查看第九个问题.</p><h2 id="20-闭包"><a href="#20-闭包" class="headerlink" title="20 闭包"></a>20 闭包</h2><p>闭包(closure)是函数式编程的重要的语法结构。闭包也是一种组织代码的结构，它同样提高了代码的可重复使用性。</p><p>当一个内嵌函数引用其外部作作用域的变量,我们就会得到一个闭包. 总结一下,创建一个闭包必须满足以下几点:</p><ol><li>必须有一个内嵌函数</li><li>内嵌函数必须引用外部函数中的变量</li><li>外部函数的返回值必须是内嵌函数</li></ol><p>感觉闭包还是有难度的,几句话是说不明白的,还是查查相关资料.</p><p>重点是函数运行后并不会被撤销,就像16题的instance字典一样,当函数运行完后,instance并不被销毁,而是继续留在内存空间里.这个功能类似类里的类变量,只不过迁移到了函数上.</p><p>闭包就像个空心球一样,你知道外面和里面,但你不知道中间是什么样.</p><h2 id="21-lambda函数"><a href="#21-lambda函数" class="headerlink" title="21 lambda函数"></a>21 lambda函数</h2><p>其实就是一个匿名函数,为什么叫lambda?因为和后面的函数式编程有关.</p><p>推荐: <a href="http://www.zhihu.com/question/20125256" target="_blank" rel="noopener">知乎</a></p><h2 id="22-Python函数式编程"><a href="#22-Python函数式编程" class="headerlink" title="22 Python函数式编程"></a>22 Python函数式编程</h2><p>这个需要适当的了解一下吧,毕竟函数式编程在Python中也做了引用.</p><p>推荐: <a href="http://coolshell.cn/articles/10822.html" target="_blank" rel="noopener">酷壳</a></p><p>python中函数式编程支持:</p><p>filter 函数的功能相当于过滤器。调用一个布尔函数<code>bool_func</code>来迭代遍历每个seq中的元素；返回一个使<code>bool_seq</code>返回值为true的元素的序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">&gt;&gt;&gt;b = filter(<span class="keyword">lambda</span> x: x &gt; <span class="number">5</span>, a)</span><br><span class="line">&gt;&gt;&gt;<span class="keyword">print</span> b</span><br><span class="line">&gt;&gt;&gt;[<span class="number">6</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure><p>map函数是对一个序列的每个项依次执行函数，下面是对一个序列每个项都乘以2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = map(<span class="keyword">lambda</span> x:x*<span class="number">2</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(a)</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure><p>reduce函数是对一个序列的每个项迭代调用函数，下面是求3的阶乘：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x,y:x*y,range(<span class="number">1</span>,<span class="number">4</span>))</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><h2 id="23-Python里的拷贝"><a href="#23-Python里的拷贝" class="headerlink" title="23 Python里的拷贝"></a>23 Python里的拷贝</h2><p>引用和copy(),deepcopy()的区别</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]]  <span class="comment">#原始对象</span></span><br><span class="line"></span><br><span class="line">b = a  <span class="comment">#赋值，传对象的引用</span></span><br><span class="line">c = copy.copy(a)  <span class="comment">#对象拷贝，浅拷贝</span></span><br><span class="line">d = copy.deepcopy(a)  <span class="comment">#对象拷贝，深拷贝</span></span><br><span class="line"></span><br><span class="line">a.append(<span class="number">5</span>)  <span class="comment">#修改对象a</span></span><br><span class="line">a[<span class="number">4</span>].append(<span class="string">'c'</span>)  <span class="comment">#修改对象a中的['a', 'b']数组对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'a = '</span>, a</span><br><span class="line"><span class="keyword">print</span> <span class="string">'b = '</span>, b</span><br><span class="line"><span class="keyword">print</span> <span class="string">'c = '</span>, c</span><br><span class="line"><span class="keyword">print</span> <span class="string">'d = '</span>, d</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">a =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], <span class="number">5</span>]</span><br><span class="line">b =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], <span class="number">5</span>]</span><br><span class="line">c =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]]</span><br><span class="line">d =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]]</span><br></pre></td></tr></table></figure><h2 id="24-Python垃圾回收机制"><a href="#24-Python垃圾回收机制" class="headerlink" title="24 Python垃圾回收机制"></a>24 Python垃圾回收机制</h2><p>Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率。</p><h3 id="1-引用计数"><a href="#1-引用计数" class="headerlink" title="1 引用计数"></a>1 引用计数</h3><p>PyObject是每个对象必有的内容，其中<code>ob_refcnt</code>就是做为引用计数。当一个对象有新的引用时，它的<code>ob_refcnt</code>就会增加，当引用它的对象被删除，它的<code>ob_refcnt</code>就会减少.引用计数为0时，该对象生命就结束了。</p><p>优点:</p><ol><li>简单</li><li>实时性</li></ol><p>缺点:</p><ol><li>维护引用计数消耗资源</li><li>循环引用</li></ol><h3 id="2-标记-清除机制"><a href="#2-标记-清除机制" class="headerlink" title="2 标记-清除机制"></a>2 标记-清除机制</h3><p>基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。</p><h3 id="3-分代技术"><a href="#3-分代技术" class="headerlink" title="3 分代技术"></a>3 分代技术</h3><p>分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。</p><p>Python默认定义了三代对象集合，索引数越大，对象存活时间越长。</p><p>举例：<br>当某些内存块M经过了3次垃圾收集的清洗之后还存活时，我们就将内存块M划到一个集合A中去，而新分配的内存都划分到集合B中去。当垃圾收集开始工作时，大多数情况都只对集合B进行垃圾回收，而对集合A进行垃圾回收要隔相当长一段时间后才进行，这就使得垃圾收集机制需要处理的内存少了，效率自然就提高了。在这个过程中，集合B中的某些内存块由于存活时间长而会被转移到集合A中，当然，集合A中实际上也存在一些垃圾，这些垃圾的回收会因为这种分代的机制而被延迟。</p><h2 id="25-Python的List"><a href="#25-Python的List" class="headerlink" title="25 Python的List"></a>25 Python的List</h2><p>推荐: <a href="http://www.jianshu.com/p/J4U6rR" target="_blank" rel="noopener">http://www.jianshu.com/p/J4U6rR</a></p><h2 id="26-Python的is"><a href="#26-Python的is" class="headerlink" title="26 Python的is"></a>26 Python的is</h2><p>is是对比地址,==是对比值</p><h2 id="27-read-readline和readlines"><a href="#27-read-readline和readlines" class="headerlink" title="27 read,readline和readlines"></a>27 read,readline和readlines</h2><ul><li>read        读取整个文件</li><li>readline    读取下一行,使用生成器方法</li><li>readlines   读取整个文件到一个迭代器以供我们遍历</li></ul><h2 id="28-Python2和3的区别"><a href="#28-Python2和3的区别" class="headerlink" title="28 Python2和3的区别"></a>28 Python2和3的区别</h2><p>推荐：<a href="http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/" target="_blank" rel="noopener">Python 2.7.x 与 Python 3.x 的主要差异</a></p><h2 id="29-super-init"><a href="#29-super-init" class="headerlink" title="29 super init"></a>29 super init</h2><p>super() lets you avoid referring to the base class explicitly, which can be nice. But the main advantage comes with multiple inheritance, where all sorts of fun stuff can happen. See the standard docs on super if you haven’t already.</p><p>Note that the syntax changed in Python 3.0: you can just say super().<code>__init__</code>() instead of super(ChildB, self).<code>__init__</code>() which IMO is quite a bit nicer.</p><p><a href="http://stackoverflow.com/questions/576169/understanding-python-super-with-init-methods" target="_blank" rel="noopener">http://stackoverflow.com/questions/576169/understanding-python-super-with-init-methods</a></p><p><a href="http://blog.csdn.net/mrlevo520/article/details/51712440" target="_blank" rel="noopener">Python2.7中的super方法浅见</a></p><h2 id="30-range-and-xrange"><a href="#30-range-and-xrange" class="headerlink" title="30 range and xrange"></a>30 range and xrange</h2><p>都在循环时使用，xrange内存性能更好。<br>for i in range(0, 20):<br>for i in xrange(0, 20):<br>What is the difference between range and xrange functions in Python 2.X?<br> range creates a list, so if you do range(1, 10000000) it creates a list in memory with 9999999 elements.<br> xrange is a sequence object that evaluates lazily.</p><p><a href="http://stackoverflow.com/questions/94935/what-is-the-difference-between-range-and-xrange-functions-in-python-2-x" target="_blank" rel="noopener">http://stackoverflow.com/questions/94935/what-is-the-difference-between-range-and-xrange-functions-in-python-2-x</a></p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="1-select-poll和epoll"><a href="#1-select-poll和epoll" class="headerlink" title="1 select,poll和epoll"></a>1 select,poll和epoll</h2><p>其实所有的I/O都是轮询的方法,只不过实现的层面不同罢了.</p><p>这个问题可能有点深入了,但相信能回答出这个问题是对I/O多路复用有很好的了解了.其中tornado使用的就是epoll的.</p><p><a href="http://www.cnblogs.com/Anker/p/3265058.html" target="_blank" rel="noopener">selec,poll和epoll区别总结</a></p><p>基本上select有3个缺点:</p><ol><li>连接数受限</li><li>查找配对速度慢</li><li>数据由内核拷贝到用户态</li></ol><p>poll改善了第一个缺点</p><p>epoll改了三个缺点.</p><p>关于epoll的: <a href="http://www.cnblogs.com/my_life/articles/3968782.html" target="_blank" rel="noopener">http://www.cnblogs.com/my_life/articles/3968782.html</a></p><h2 id="2-调度算法"><a href="#2-调度算法" class="headerlink" title="2 调度算法"></a>2 调度算法</h2><ol><li>先来先服务(FCFS, First Come First Serve)</li><li>短作业优先(SJF, Shortest Job First)</li><li>最高优先权调度(Priority Scheduling)</li><li>时间片轮转(RR, Round Robin)</li><li>多级反馈队列调度(multilevel feedback queue scheduling)</li></ol><p>常见的调度算法总结:<a href="http://www.jianshu.com/p/6edf8174c1eb" target="_blank" rel="noopener">http://www.jianshu.com/p/6edf8174c1eb</a></p><p>实时调度算法:</p><ol><li>最早截至时间优先 EDF</li><li>最低松弛度优先 LLF</li></ol><h2 id="3-死锁"><a href="#3-死锁" class="headerlink" title="3 死锁"></a>3 死锁</h2><p>原因:</p><ol><li>竞争资源</li><li>程序推进顺序不当</li></ol><p>必要条件:</p><ol><li>互斥条件</li><li>请求和保持条件</li><li>不剥夺条件</li><li>环路等待条件</li></ol><p>处理死锁基本方法:</p><ol><li>预防死锁(摒弃除1以外的条件)</li><li>避免死锁(银行家算法)</li><li>检测死锁(资源分配图)</li><li>解除死锁<ol><li>剥夺资源</li><li>撤销进程</li></ol></li></ol><p>死锁概念处理策略详细介绍:<a href="https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/10.html" target="_blank" rel="noopener">https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/10.html</a></p><h2 id="4-程序编译与链接"><a href="#4-程序编译与链接" class="headerlink" title="4 程序编译与链接"></a>4 程序编译与链接</h2><p>推荐: <a href="http://www.ruanyifeng.com/blog/2014/11/compiler.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/11/compiler.html</a></p><p>Bulid过程可以分解为4个步骤:预处理(Prepressing), 编译(Compilation)、汇编(Assembly)、链接(Linking)</p><p>以c语言为例:</p><h3 id="1-预处理"><a href="#1-预处理" class="headerlink" title="1 预处理"></a>1 预处理</h3><p>预编译过程主要处理那些源文件中的以“#”开始的预编译指令，主要处理规则有：</p><ol><li>将所有的“#define”删除，并展开所用的宏定义</li><li>处理所有条件预编译指令，比如“#if”、“#ifdef”、 “#elif”、“#endif”</li><li>处理“#include”预编译指令，将被包含的文件插入到该编译指令的位置，注：此过程是递归进行的</li><li>删除所有注释</li><li>添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息以及用于编译时产生编译错误或警告时可显示行号</li><li>保留所有的#pragma编译器指令。</li></ol><h3 id="2-编译"><a href="#2-编译" class="headerlink" title="2 编译"></a>2 编译</h3><p>编译过程就是把预处理完的文件进行一系列的词法分析、语法分析、语义分析及优化后生成相应的汇编代码文件。这个过程是整个程序构建的核心部分。</p><h3 id="3-汇编"><a href="#3-汇编" class="headerlink" title="3 汇编"></a>3 汇编</h3><p>汇编器是将汇编代码转化成机器可以执行的指令，每一条汇编语句几乎都是一条机器指令。经过编译、链接、汇编输出的文件成为目标文件(Object File)</p><h3 id="4-链接"><a href="#4-链接" class="headerlink" title="4 链接"></a>4 链接</h3><p>链接的主要内容就是把各个模块之间相互引用的部分处理好，使各个模块可以正确的拼接。<br>链接的主要过程包块 地址和空间的分配（Address and Storage Allocation）、符号决议(Symbol Resolution)和重定位(Relocation)等步骤。</p><h2 id="5-静态链接和动态链接"><a href="#5-静态链接和动态链接" class="headerlink" title="5 静态链接和动态链接"></a>5 静态链接和动态链接</h2><p>静态链接方法：静态链接的时候，载入代码就会把程序会用到的动态代码或动态代码的地址确定下来<br>静态库的链接可以使用静态链接，动态链接库也可以使用这种方法链接导入库</p><p>动态链接方法：使用这种方式的程序并不在一开始就完成动态链接，而是直到真正调用动态库代码时，载入程序才计算(被调用的那部分)动态代码的逻辑地址，然后等到某个时候，程序又需要调用另外某块动态代码时，载入程序又去计算这部分代码的逻辑地址，所以，这种方式使程序初始化时间较短，但运行期间的性能比不上静态链接的程序</p><h2 id="6-虚拟内存技术"><a href="#6-虚拟内存技术" class="headerlink" title="6 虚拟内存技术"></a>6 虚拟内存技术</h2><p>虚拟存储器是指具有请求调入功能和置换功能,能从逻辑上对内存容量加以扩充的一种存储系统.</p><h2 id="7-分页和分段"><a href="#7-分页和分段" class="headerlink" title="7 分页和分段"></a>7 分页和分段</h2><p>分页: 用户程序的地址空间被划分成若干固定大小的区域，称为“页”，相应地，内存空间分成若干个物理块，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，实现了离散分配。</p><p>分段: 将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配。</p><h3 id="分页与分段的主要区别"><a href="#分页与分段的主要区别" class="headerlink" title="分页与分段的主要区别"></a>分页与分段的主要区别</h3><ol><li>页是信息的物理单位,分页是为了实现非连续分配,以便解决内存碎片问题,或者说分页是由于系统管理的需要.段是信息的逻辑单位,它含有一组意义相对完整的信息,分段的目的是为了更好地实现共享,满足用户的需要.</li><li>页的大小固定,由系统确定,将逻辑地址划分为页号和页内地址是由机器硬件实现的.而段的长度却不固定,决定于用户所编写的程序,通常由编译程序在对源程序进行编译时根据信息的性质来划分.</li><li>分页的作业地址空间是一维的.分段的地址空间是二维的.</li></ol><h2 id="8-页面置换算法"><a href="#8-页面置换算法" class="headerlink" title="8 页面置换算法"></a>8 页面置换算法</h2><ol><li>最佳置换算法OPT:不可能实现</li><li>先进先出FIFO</li><li>最近最久未使用算法LRU:最近一段时间里最久没有使用过的页面予以置换.</li><li>clock算法</li></ol><h2 id="9-边沿触发和水平触发"><a href="#9-边沿触发和水平触发" class="headerlink" title="9 边沿触发和水平触发"></a>9 边沿触发和水平触发</h2><p>边缘触发是指每当状态变化时发生一个 io 事件，条件触发是只要满足条件就发生一个 io 事件</p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="1-事务"><a href="#1-事务" class="headerlink" title="1 事务"></a>1 事务</h2><p>数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。<br>彻底理解数据库事务: <a href="http://www.hollischuang.com/archives/898" target="_blank" rel="noopener">http://www.hollischuang.com/archives/898</a></p><h2 id="2-数据库索引"><a href="#2-数据库索引" class="headerlink" title="2 数据库索引"></a>2 数据库索引</h2><p>推荐: <a href="http://tech.meituan.com/mysql-index.html" target="_blank" rel="noopener">http://tech.meituan.com/mysql-index.html</a></p><p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></p><p>聚集索引,非聚集索引,B-Tree,B+Tree,最左前缀原理</p><h2 id="3-Redis原理"><a href="#3-Redis原理" class="headerlink" title="3 Redis原理"></a>3 Redis原理</h2><h3 id="Redis是什么？"><a href="#Redis是什么？" class="headerlink" title="Redis是什么？"></a>Redis是什么？</h3><ol><li>是一个完全开源免费的key-value内存数据库 </li><li>通常被认为是一个数据结构服务器，主要是因为其有着丰富的数据结构 strings、map、 list、sets、 sorted sets</li></ol><h3 id="Redis数据库"><a href="#Redis数据库" class="headerlink" title="Redis数据库"></a>Redis数据库</h3><blockquote><p>​    通常局限点来说，Redis也以消息队列的形式存在，作为内嵌的List存在，满足实时的高并发需求。在使用缓存的时候，redis比memcached具有更多的优势，并且支持更多的数据类型，把redis当作一个中间存储系统，用来处理高并发的数据库操作</p></blockquote><ul><li>速度快：使用标准C写，所有数据都在内存中完成，读写速度分别达到10万/20万 </li><li>持久化：对数据的更新采用Copy-on-write技术，可以异步地保存到磁盘上，主要有两种策略，一是根据时间，更新次数的快照（save 300 10 ）二是基于语句追加方式(Append-only file，aof) </li><li>自动操作：对不同数据类型的操作都是自动的，很安全 </li><li>快速的主–从复制，官方提供了一个数据，Slave在21秒即完成了对Amazon网站10G key set的复制。 </li><li>Sharding技术： 很容易将数据分布到多个Redis实例中，数据库的扩展是个永恒的话题，在关系型数据库中，主要是以添加硬件、以分区为主要技术形式的纵向扩展解决了很多的应用场景，但随着web2.0、移动互联网、云计算等应用的兴起，这种扩展模式已经不太适合了，所以近年来，像采用主从配置、数据库复制形式的，Sharding这种技术把负载分布到多个特理节点上去的横向扩展方式用处越来越多。</li></ul><h3 id="Redis缺点"><a href="#Redis缺点" class="headerlink" title="Redis缺点"></a>Redis缺点</h3><ul><li>是数据库容量受到物理内存的限制,不能用作海量数据的高性能读写,因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</li><li>Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</li></ul><h2 id="4-乐观锁和悲观锁"><a href="#4-乐观锁和悲观锁" class="headerlink" title="4 乐观锁和悲观锁"></a>4 乐观锁和悲观锁</h2><p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作</p><p>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</p><p>乐观锁与悲观锁的具体区别: <a href="http://www.cnblogs.com/Bob-FD/p/3352216.html" target="_blank" rel="noopener">http://www.cnblogs.com/Bob-FD/p/3352216.html</a></p><h2 id="5-MVCC"><a href="#5-MVCC" class="headerlink" title="5 MVCC"></a>5 MVCC</h2><blockquote><p>​    全称是Multi-Version Concurrent Control，即多版本并发控制，在MVCC协议下，每个读操作会看到一个一致性的snapshot，并且可以实现非阻塞的读。MVCC允许数据具有多个版本，这个版本可以是时间戳或者是全局递增的事务ID，在同一个时间点，不同的事务看到的数据是不同的。</p></blockquote><h3 id="MySQL的innodb引擎是如何实现MVCC的"><a href="#MySQL的innodb引擎是如何实现MVCC的" class="headerlink" title="MySQL的innodb引擎是如何实现MVCC的"></a><a href="http://lib.csdn.net/base/mysql" target="_blank" rel="noopener">MySQL</a>的innodb引擎是如何实现MVCC的</h3><p>innodb会为每一行添加两个字段，分别表示该行<strong>创建的版本</strong>和<strong>删除的版本</strong>，填入的是事务的版本号，这个版本号随着事务的创建不断递增。在repeated read的隔离级别（<a href="http://blog.csdn.net/chosen0ne/article/details/10036775" target="_blank" rel="noopener">事务的隔离级别请看这篇文章</a>）下，具体各种数据库操作的实现：</p><ul><li>select：满足以下两个条件innodb会返回该行数据：<ul><li>该行的创建版本号小于等于当前版本号，用于保证在select操作之前所有的操作已经执行落地。</li><li>该行的删除版本号大于当前版本或者为空。删除版本号大于当前版本意味着有一个并发事务将该行删除了。</li></ul></li><li>insert：将新插入的行的创建版本号设置为当前系统的版本号。</li><li>delete：将要删除的行的删除版本号设置为当前系统的版本号。</li><li>update：不执行原地update，而是转换成insert + delete。将旧行的删除版本号设置为当前版本号，并将新行insert同时设置创建版本号为当前版本号。</li></ul><p>其中，写操作（insert、delete和update）执行时，需要将系统版本号递增。</p><p>​    由于旧数据并不真正的删除，所以必须对这些数据进行清理，innodb会开启一个后台线程执行清理工作，具体的规则是将删除版本号小于当前系统版本的行删除，这个过程叫做purge。</p><p>通过MVCC很好的实现了事务的隔离性，可以达到repeated read级别，要实现serializable还必须加锁。</p><blockquote><p> 参考：<a href="http://blog.csdn.net/chosen0ne/article/details/18093187" target="_blank" rel="noopener">MVCC浅析</a></p></blockquote><h2 id="6-MyISAM和InnoDB"><a href="#6-MyISAM和InnoDB" class="headerlink" title="6 MyISAM和InnoDB"></a>6 MyISAM和InnoDB</h2><p>MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 SELECT COUNT(*) 这类的计算是超快无比的。</p><p>InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。</p><p>mysql 数据库引擎: <a href="http://www.cnblogs.com/0201zcr/p/5296843.html" target="_blank" rel="noopener">http://www.cnblogs.com/0201zcr/p/5296843.html</a><br>MySQL存储引擎－－MyISAM与InnoDB区别: <a href="https://segmentfault.com/a/1190000008227211" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008227211</a></p><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="1-三次握手"><a href="#1-三次握手" class="headerlink" title="1 三次握手"></a>1 三次握手</h2><ol><li>客户端通过向服务器端发送一个SYN来创建一个主动打开，作为三次握手的一部分。客户端把这段连接的序号设定为随机数 A。</li><li>服务器端应当为一个合法的SYN回送一个SYN/ACK。ACK 的确认码应为 A+1，SYN/ACK 包本身又有一个随机序号 B。</li><li>最后，客户端再发送一个ACK。当服务端受到这个ACK的时候，就完成了三路握手，并进入了连接创建状态。此时包序号被设定为收到的确认号 A+1，而响应则为 B+1。</li></ol><h2 id="2-四次挥手"><a href="#2-四次挥手" class="headerlink" title="2 四次挥手"></a>2 四次挥手</h2><p><em>注意: 中断连接端可以是客户端，也可以是服务器端. 下面仅以客户端断开连接举例, 反之亦然.</em></p><ol><li>客户端发送一个数据分段, 其中的 FIN 标记设置为1. 客户端进入 FIN-WAIT 状态. 该状态下客户端只接收数据, 不再发送数据.</li><li>服务器接收到带有 FIN = 1 的数据分段, 发送带有 ACK = 1 的剩余数据分段, 确认收到客户端发来的 FIN 信息.</li><li>服务器等到所有数据传输结束, 向客户端发送一个带有 FIN = 1 的数据分段, 并进入 CLOSE-WAIT 状态, 等待客户端发来带有 ACK = 1 的确认报文.</li><li>客户端收到服务器发来带有 FIN = 1 的报文, 返回 ACK = 1 的报文确认, 为了防止服务器端未收到需要重发, 进入 TIME-WAIT 状态. 服务器接收到报文后关闭连接. 客户端等待 2MSL 后未收到回复, 则认为服务器成功关闭, 客户端关闭连接.</li></ol><p>图解: <a href="http://blog.csdn.net/whuslei/article/details/6667471" target="_blank" rel="noopener">http://blog.csdn.net/whuslei/article/details/6667471</a></p><h2 id="3-ARP协议"><a href="#3-ARP协议" class="headerlink" title="3 ARP协议"></a>3 ARP协议</h2><p>地址解析协议(Address Resolution Protocol)，其基本功能为透过目标设备的IP地址，查询目标的MAC地址，以保证通信的顺利进行。它是IPv4网络层必不可少的协议，不过在IPv6中已不再适用，并被邻居发现协议（NDP）所替代。</p><h2 id="4-urllib和urllib2的区别"><a href="#4-urllib和urllib2的区别" class="headerlink" title="4 urllib和urllib2的区别"></a>4 urllib和urllib2的区别</h2><p>这个面试官确实问过,当时答的urllib2可以Post而urllib不可以.</p><ol><li>urllib提供urlencode方法用来GET查询字符串的产生，而urllib2没有。这是为何urllib常和urllib2一起使用的原因。</li><li>urllib2可以接受一个Request类的实例来设置URL请求的headers，urllib仅可以接受URL。这意味着，你不可以伪装你的User Agent字符串等。</li></ol><h2 id="5-Post和Get"><a href="#5-Post和Get" class="headerlink" title="5 Post和Get"></a>5 Post和Get</h2><p><a href="http://www.cnblogs.com/nankezhishi/archive/2012/06/09/getandpost.html" target="_blank" rel="noopener">GET和POST有什么区别？及为什么网上的多数答案都是错的</a><br><a href="https://www.zhihu.com/question/31640769?rf=37401322" target="_blank" rel="noopener">知乎回答</a></p><p>get: <a href="http://tools.ietf.org/html/rfc2616#section-9.3" target="_blank" rel="noopener">RFC 2616 - Hypertext Transfer Protocol – HTTP/1.1</a><br>post: <a href="http://tools.ietf.org/html/rfc2616#section-9.5" target="_blank" rel="noopener">RFC 2616 - Hypertext Transfer Protocol – HTTP/1.1</a></p><h2 id="6-Cookie和Session"><a href="#6-Cookie和Session" class="headerlink" title="6 Cookie和Session"></a>6 Cookie和Session</h2><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">Cookie</th><th style="text-align:left">Session</th></tr></thead><tbody><tr><td style="text-align:left">储存位置</td><td style="text-align:left">客户端</td><td style="text-align:left">服务器端</td></tr><tr><td style="text-align:left">目的</td><td style="text-align:left">跟踪会话，也可以保存用户偏好设置或者保存用户名密码等</td><td style="text-align:left">跟踪会话</td></tr><tr><td style="text-align:left">安全性</td><td style="text-align:left">不安全</td><td style="text-align:left">安全</td></tr></tbody></table><p>session技术是要使用到cookie的，之所以出现session技术，主要是为了安全。</p><h2 id="7-apache和nginx的区别"><a href="#7-apache和nginx的区别" class="headerlink" title="7 apache和nginx的区别"></a>7 apache和nginx的区别</h2><p>nginx 相对 apache 的优点：</p><ul><li>轻量级，同样起web 服务，比apache 占用更少的内存及资源</li><li>抗并发，nginx 处理请求是异步非阻塞的，支持更多的并发连接，而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能</li><li>配置简洁</li><li>高度模块化的设计，编写模块相对简单</li><li>社区活跃</li></ul><p>apache 相对nginx 的优点：</p><ul><li>rewrite ，比nginx 的rewrite 强大</li><li>模块超多，基本想到的都可以找到</li><li>少bug ，nginx 的bug 相对较多</li><li>超稳定</li></ul><h2 id="8-网站用户密码保存"><a href="#8-网站用户密码保存" class="headerlink" title="8 网站用户密码保存"></a>8 网站用户密码保存</h2><ol><li>明文保存</li><li>明文hash后保存,如md5</li><li>MD5+Salt方式,这个salt可以随机</li><li>知乎使用了Bcrypy(好像)加密</li></ol><h2 id="9-HTTP和HTTPS"><a href="#9-HTTP和HTTPS" class="headerlink" title="9 HTTP和HTTPS"></a>9 HTTP和HTTPS</h2><table><thead><tr><th style="text-align:left">状态码</th><th style="text-align:left">定义</th></tr></thead><tbody><tr><td style="text-align:left">1xx 报告</td><td style="text-align:left">接收到请求，继续进程</td></tr><tr><td style="text-align:left">2xx 成功</td><td style="text-align:left">步骤成功接收，被理解，并被接受</td></tr><tr><td style="text-align:left">3xx 重定向</td><td style="text-align:left">为了完成请求,必须采取进一步措施</td></tr><tr><td style="text-align:left">4xx 客户端出错</td><td style="text-align:left">请求包括错的顺序或不能完成</td></tr><tr><td style="text-align:left">5xx 服务器出错</td><td style="text-align:left">服务器无法完成显然有效的请求</td></tr></tbody></table><p>403: Forbidden<br>404: Not Found</p><p>HTTPS握手,对称加密,非对称加密,TLS/SSL,RSA</p><h2 id="10-XSRF和XSS"><a href="#10-XSRF和XSS" class="headerlink" title="10 XSRF和XSS"></a>10 XSRF和XSS</h2><ul><li>CSRF(Cross-site request forgery)跨站请求伪造</li><li>XSS(Cross Site Scripting)跨站脚本攻击</li></ul><p>CSRF重点在请求,XSS重点在脚本</p><h2 id="11-幂等-Idempotence"><a href="#11-幂等-Idempotence" class="headerlink" title="11 幂等 Idempotence"></a>11 幂等 Idempotence</h2><p>HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的<strong>副作用</strong>。(注意是副作用)</p><p><code>GET http://www.bank.com/account/123456</code>，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。<code>GET http://www.news.com/latest-news</code>这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。</p><p>DELETE方法用于删除资源，有副作用，但它应该满足幂等性。比如：<code>DELETE http://www.forum.com/article/4231</code>，调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。</p><p>POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：<code>POST http://www.forum.com/articles</code>的语义是在<code>http://www.forum.com/articles</code>下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。</p><p>PUT所对应的URI是要创建或更新的资源本身。比如：<code>PUT http://www.forum/articles/4231</code>的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。</p><h2 id="12-RESTful架构-SOAP-RPC"><a href="#12-RESTful架构-SOAP-RPC" class="headerlink" title="12 RESTful架构(SOAP,RPC)"></a>12 RESTful架构(SOAP,RPC)</h2><p>推荐: <a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/09/restful.html</a></p><h2 id="13-SOAP"><a href="#13-SOAP" class="headerlink" title="13 SOAP"></a>13 SOAP</h2><p>SOAP（原为Simple Object Access Protocol的首字母缩写，即简单对象访问协议）是交换数据的一种协议规范，使用在计算机网络Web服务（web service）中，交换带结构信息。SOAP为了简化网页服务器（Web Server）从XML数据库中提取数据时，节省去格式化页面时间，以及不同应用程序之间按照HTTP通信协议，遵从XML格式执行资料互换，使其抽象于语言实现、平台和硬件。</p><h2 id="14-RPC"><a href="#14-RPC" class="headerlink" title="14 RPC"></a>14 RPC</h2><p>RPC（Remote Procedure Call Protocol）——远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。</p><p>总结:服务提供的两大流派.传统意义以方法调用为导向通称RPC。为了企业SOA,若干厂商联合推出webservice,制定了wsdl接口定义,传输soap.当互联网时代,臃肿SOA被简化为http+xml/json.但是简化出现各种混乱。以资源为导向,任何操作无非是对资源的增删改查，于是统一的REST出现了.</p><p>进化的顺序: RPC -&gt; SOAP -&gt; RESTful</p><h2 id="15-CGI和WSGI"><a href="#15-CGI和WSGI" class="headerlink" title="15 CGI和WSGI"></a>15 CGI和WSGI</h2><p>CGI是通用网关接口，是连接web服务器和应用程序的接口，用户通过CGI来获取动态数据或文件等。<br>CGI程序是一个独立的程序，它可以用几乎所有语言来写，包括perl，c，lua，python等等。</p><p>WSGI, Web Server Gateway Interface，是Python应用程序或框架和Web服务器之间的一种接口，WSGI的其中一个目的就是让用户可以用统一的语言(Python)编写前后端。</p><p>官方说明：<a href="https://www.python.org/dev/peps/pep-3333/" target="_blank" rel="noopener">PEP-3333</a></p><h2 id="16-中间人攻击"><a href="#16-中间人攻击" class="headerlink" title="16 中间人攻击"></a>16 中间人攻击</h2><p>在GFW里屡见不鲜的,呵呵.</p><p>中间人攻击（Man-in-the-middle attack，通常缩写为MITM）是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。</p><h2 id="17-c10k问题"><a href="#17-c10k问题" class="headerlink" title="17 c10k问题"></a>17 c10k问题</h2><p>所谓c10k问题，指的是服务器同时支持成千上万个客户端的问题，也就是concurrent 10 000 connection（这也是c10k这个名字的由来）。<br>推荐: <a href="https://my.oschina.net/xianggao/blog/664275" target="_blank" rel="noopener">https://my.oschina.net/xianggao/blog/664275</a></p><h2 id="18-socket"><a href="#18-socket" class="headerlink" title="18 socket"></a>18 socket</h2><p>推荐: <a href="http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml</a></p><p>Socket=Ip address+ TCP/UDP + port</p><h2 id="19-浏览器缓存"><a href="#19-浏览器缓存" class="headerlink" title="19 浏览器缓存"></a>19 浏览器缓存</h2><p>推荐: <a href="http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html" target="_blank" rel="noopener">http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html</a></p><p>304 Not Modified</p><h2 id="20-HTTP1-0和HTTP1-1"><a href="#20-HTTP1-0和HTTP1-1" class="headerlink" title="20 HTTP1.0和HTTP1.1"></a>20 HTTP1.0和HTTP1.1</h2><p>推荐: <a href="http://blog.csdn.net/elifefly/article/details/3964766" target="_blank" rel="noopener">http://blog.csdn.net/elifefly/article/details/3964766</a></p><ol><li>请求头Host字段,一个服务器多个网站</li><li>长链接</li><li>文件断点续传</li><li>身份认证,状态管理,Cache缓存</li></ol><p>HTTP请求8种方法介绍<br>HTTP/1.1协议中共定义了8种HTTP请求方法，HTTP请求方法也被叫做“请求动作”，不同的方法规定了不同的操作指定的资源方式。服务端也会根据不同的请求方法做不同的响应。</p><p>GET</p><p>GET请求会显示请求指定的资源。一般来说GET方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中。</p><p>GET会方法请求指定的页面信息，并返回响应主体，GET被认为是不安全的方法，因为GET方法会被网络蜘蛛等任意的访问。</p><p>HEAD</p><p>HEAD方法与GET方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应HEAD请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD方法常被用于客户端查看服务器的性能。</p><p>POST</p><p>POST请求会 向指定资源提交数据，请求服务器进行处理，如：表单数据提交、文件上传等，请求数据会被包含在请求体中。POST方法是非幂等的方法，因为这个请求可能会创建新的资源或/和修改现有资源。</p><p>PUT</p><p>PUT请求会身向指定资源位置上传其最新内容，PUT方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。</p><p>DELETE</p><p>DELETE请求用于请求服务器删除所请求URI（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE请求后指定资源会被删除，DELETE方法也是幂等的。</p><p>CONNECT</p><p>CONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。</p><p>OPTIONS</p><p>OPTIONS请求与HEAD类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用’*’来代替资源名称，向服务器发送OPTIONS请求，可以测试服务器功能是否正常。JavaScript的XMLHttpRequest对象进行CORS跨域资源共享时，就是使用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限。 允许</p><p>TRACE</p><p>TRACE请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。</p><p>HTTP/1.1之后增加的方法</p><p>在HTTP/1.1标准制定之后，又陆续扩展了一些方法。其中使用中较多的是 PATCH 方法：</p><p>PATCH</p><p>PATCH方法出现的较晚，它在2010年的RFC 5789标准中被定义。PATCH请求与PUT请求类似，同样用于资源的更新。二者有以下两点不同：</p><p>但PATCH一般用于资源的部分更新，而PUT一般用于资源的整体更新。<br>当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已在资源进行更新。</p><h2 id="21-Ajax"><a href="#21-Ajax" class="headerlink" title="21 Ajax"></a>21 Ajax</h2><p>AJAX,Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）, 是与在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术。</p><h1 id="NIX"><a href="#NIX" class="headerlink" title="*NIX"></a>*NIX</h1><h2 id="unix进程间通信方式-IPC"><a href="#unix进程间通信方式-IPC" class="headerlink" title="unix进程间通信方式(IPC)"></a>unix进程间通信方式(IPC)</h2><ol><li>管道（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。</li><li>命名管道（named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。</li><li>信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。</li><li>消息（Message）队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺</li><li>共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。</li><li>内存映射（mapped memory）：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。</li><li>信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。</li><li>套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。</li></ol><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="1-红黑树"><a href="#1-红黑树" class="headerlink" title="1 红黑树"></a>1 红黑树</h2><p>红黑树与AVL的比较：</p><p>AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多；</p><p>红黑是用非严格的平衡来换取增删节点时候旋转次数的降低；</p><p>所以简单说，如果你的应用中，搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。</p><p>红黑树详解: <a href="https://xieguanglei.github.io/blog/post/red-black-tree.html" target="_blank" rel="noopener">https://xieguanglei.github.io/blog/post/red-black-tree.html</a></p><p>教你透彻了解红黑树: <a href="https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md" target="_blank" rel="noopener">https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md</a></p><h1 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h1><h2 id="1-台阶问题-斐波那契"><a href="#1-台阶问题-斐波那契" class="headerlink" title="1 台阶问题/斐波那契"></a>1 台阶问题/斐波那契</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fib = <span class="keyword">lambda</span> n: n <span class="keyword">if</span> n &lt;= <span class="number">2</span> <span class="keyword">else</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>第二种记忆方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">memo</span><span class="params">(func)</span>:</span></span><br><span class="line">    cache = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrap</span><span class="params">(*args)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> args <span class="keyword">not</span> <span class="keyword">in</span> cache:</span><br><span class="line">            cache[args] = func(*args)</span><br><span class="line">        <span class="keyword">return</span> cache[args]</span><br><span class="line">    <span class="keyword">return</span> wrap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@memo</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> fib(i<span class="number">-1</span>) + fib(i<span class="number">-2</span>)</span><br></pre></td></tr></table></figure><p>第三种方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(n):</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">    <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure><h2 id="2-变态台阶问题"><a href="#2-变态台阶问题" class="headerlink" title="2 变态台阶问题"></a>2 变态台阶问题</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fib = <span class="keyword">lambda</span> n: n <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> <span class="number">2</span> * fib(n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="3-矩形覆盖"><a href="#3-矩形覆盖" class="headerlink" title="3 矩形覆盖"></a>3 矩形覆盖</h2><p>我们可以用<code>2*1</code>的小矩形横着或者竖着去覆盖更大的矩形。请问用n个<code>2*1</code>的小矩形无重叠地覆盖一个<code>2*n</code>的大矩形，总共有多少种方法？</p><blockquote><p>第<code>2*n</code>个矩形的覆盖方法等于第<code>2*(n-1)</code>加上第<code>2*(n-2)</code>的方法。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="keyword">lambda</span> n: <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="4-杨氏矩阵查找"><a href="#4-杨氏矩阵查找" class="headerlink" title="4 杨氏矩阵查找"></a>4 杨氏矩阵查找</h2><p>在一个m行n列二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>使用Step-wise线性搜索。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_value</span><span class="params">(l, r, c)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> l[r][c]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(l, x)</span>:</span></span><br><span class="line">    m = len(l) - <span class="number">1</span></span><br><span class="line">    n = len(l[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">    r = <span class="number">0</span></span><br><span class="line">    c = n</span><br><span class="line">    <span class="keyword">while</span> c &gt;= <span class="number">0</span> <span class="keyword">and</span> r &lt;= m:</span><br><span class="line">        value = get_value(l, r, c)</span><br><span class="line">        <span class="keyword">if</span> value == x:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">elif</span> value &gt; x:</span><br><span class="line">            c = c - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> value &lt; x:</span><br><span class="line">            r = r + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h2 id="5-去除列表中的重复元素"><a href="#5-去除列表中的重复元素" class="headerlink" title="5 去除列表中的重复元素"></a>5 去除列表中的重复元素</h2><p>用集合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(set(l))</span><br></pre></td></tr></table></figure><p>用字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>]</span><br><span class="line">l2 = &#123;&#125;.fromkeys(l1).keys()</span><br><span class="line"><span class="keyword">print</span> l2</span><br></pre></td></tr></table></figure><p>用字典并保持顺序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>]</span><br><span class="line">l2 = list(set(l1))</span><br><span class="line">l2.sort(key=l1.index)</span><br><span class="line"><span class="keyword">print</span> l2</span><br></pre></td></tr></table></figure><p>列表推导式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>]</span><br><span class="line">l2 = []</span><br><span class="line">[l2.append(i) <span class="keyword">for</span> i <span class="keyword">in</span> l1 <span class="keyword">if</span> <span class="keyword">not</span> i <span class="keyword">in</span> l2]</span><br></pre></td></tr></table></figure><p>sorted排序并且用列表推导式.</p><p>l = [‘b’,’c’,’d’,’b’,’c’,’a’,’a’]<br>[single.append(i) for i in sorted(l) if i not in single]<br>print single</p><h2 id="6-链表成对调换"><a href="#6-链表成对调换" class="headerlink" title="6 链表成对调换"></a>6 链表成对调换</h2><p><code>1-&gt;2-&gt;3-&gt;4</code>转换成<code>2-&gt;1-&gt;4-&gt;3</code>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param a ListNode</span></span><br><span class="line">    <span class="comment"># @return a ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> head != <span class="keyword">None</span> <span class="keyword">and</span> head.next != <span class="keyword">None</span>:</span><br><span class="line">            next = head.next</span><br><span class="line">            head.next = self.swapPairs(next.next)</span><br><span class="line">            next.next = head</span><br><span class="line">            <span class="keyword">return</span> next</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h2 id="7-创建字典的方法"><a href="#7-创建字典的方法" class="headerlink" title="7 创建字典的方法"></a>7 创建字典的方法</h2><h3 id="1-直接创建"><a href="#1-直接创建" class="headerlink" title="1 直接创建"></a>1 直接创建</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict = &#123;<span class="string">'name'</span>:<span class="string">'earth'</span>, <span class="string">'port'</span>:<span class="string">'80'</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="2-工厂方法"><a href="#2-工厂方法" class="headerlink" title="2 工厂方法"></a>2 工厂方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">items=[(<span class="string">'name'</span>,<span class="string">'earth'</span>),(<span class="string">'port'</span>,<span class="string">'80'</span>)]</span><br><span class="line">dict2=dict(items)</span><br><span class="line">dict1=dict(([<span class="string">'name'</span>,<span class="string">'earth'</span>],[<span class="string">'port'</span>,<span class="string">'80'</span>]))</span><br></pre></td></tr></table></figure><h3 id="3-fromkeys-方法"><a href="#3-fromkeys-方法" class="headerlink" title="3 fromkeys()方法"></a>3 fromkeys()方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dict1=&#123;&#125;.fromkeys((<span class="string">'x'</span>,<span class="string">'y'</span>),<span class="number">-1</span>)</span><br><span class="line">dict=&#123;<span class="string">'x'</span>:<span class="number">-1</span>,<span class="string">'y'</span>:<span class="number">-1</span>&#125;</span><br><span class="line">dict2=&#123;&#125;.fromkeys((<span class="string">'x'</span>,<span class="string">'y'</span>))</span><br><span class="line">dict2=&#123;<span class="string">'x'</span>:<span class="keyword">None</span>, <span class="string">'y'</span>:<span class="keyword">None</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="8-合并两个有序列表"><a href="#8-合并两个有序列表" class="headerlink" title="8 合并两个有序列表"></a>8 合并两个有序列表</h2><p>知乎远程面试要求编程</p><blockquote><p> 尾递归</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_recursion_merge_sort2</span><span class="params">(l1, l2, tmp)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(l1) == <span class="number">0</span> <span class="keyword">or</span> len(l2) == <span class="number">0</span>:</span><br><span class="line">        tmp.extend(l1)</span><br><span class="line">        tmp.extend(l2)</span><br><span class="line">        <span class="keyword">return</span> tmp</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> l1[<span class="number">0</span>] &lt; l2[<span class="number">0</span>]:</span><br><span class="line">            tmp.append(l1[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">del</span> l1[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp.append(l2[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">del</span> l2[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> _recursion_merge_sort2(l1, l2, tmp)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recursion_merge_sort2</span><span class="params">(l1, l2)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> _recursion_merge_sort2(l1, l2, [])</span><br></pre></td></tr></table></figure><blockquote><p> 循环算法</p></blockquote><p>思路：</p><p>定义一个新的空列表</p><p>比较两个列表的首个元素</p><p>小的就插入到新列表里</p><p>把已经插入新列表的元素从旧列表删除</p><p>直到两个旧列表有一个为空</p><p>再把旧列表加到新列表后面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def loop_merge_sort(l1, l2):</span><br><span class="line">    tmp = []</span><br><span class="line">    while len(l1) &gt; 0 and len(l2) &gt; 0:</span><br><span class="line">        if l1[0] &lt; l2[0]:</span><br><span class="line">            tmp.append(l1[0])</span><br><span class="line">            del l1[0]</span><br><span class="line">        else:</span><br><span class="line">            tmp.append(l2[0])</span><br><span class="line">            del l2[0]</span><br><span class="line">    tmp.extend(l1)</span><br><span class="line">    tmp.extend(l2)</span><br><span class="line">    return tmp</span><br></pre></td></tr></table></figure><blockquote><p>pop弹出</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">b = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sortedlist</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    c = []</span><br><span class="line">    <span class="keyword">while</span> a <span class="keyword">and</span> b:</span><br><span class="line">        <span class="keyword">if</span> a[<span class="number">0</span>] &gt;= b[<span class="number">0</span>]:</span><br><span class="line">            c.append(b.pop(<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            c.append(a.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">while</span> a:</span><br><span class="line">        c.append(a.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">while</span> b:</span><br><span class="line">        c.append(b.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"><span class="keyword">print</span> merge_sortedlist(a,b)</span><br></pre></td></tr></table></figure><h2 id="9-交叉链表求交点"><a href="#9-交叉链表求交点" class="headerlink" title="9 交叉链表求交点"></a>9 交叉链表求交点</h2><blockquote><p>其实思想可以按照从尾开始比较两个链表，如果相交，则从尾开始必然一致，只要从尾开始比较，直至不一致的地方即为交叉点，如图所示</p></blockquote><p><img src="http://hi.csdn.net/attachment/201106/28/0_1309244136MWLP.gif" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用a,b两个list来模拟链表，可以看出交叉点是 7这个节点</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line">b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,min(len(a),len(b))):</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">1</span> <span class="keyword">and</span> (a[<span class="number">-1</span>] != b[<span class="number">-1</span>]):</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"No"</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> a[-i] != b[-i]:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"交叉节点："</span>,a[-i+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><blockquote><p>另外一种比较正规的方法，构造链表类</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">node</span><span class="params">(l1, l2)</span>:</span></span><br><span class="line">    length1, lenth2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment"># 求两个链表长度</span></span><br><span class="line">    <span class="keyword">while</span> l1.next:</span><br><span class="line">        l1 = l1.next</span><br><span class="line">        length1 += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l2.next:</span><br><span class="line">        l2 = l2.next</span><br><span class="line">        length2 += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 长的链表先走</span></span><br><span class="line">    <span class="keyword">if</span> length1 &gt; lenth2:</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(length1 - length2):</span><br><span class="line">            l1 = l1.next</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(length2 - length1):</span><br><span class="line">            l2 = l2.next</span><br><span class="line">    <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">        <span class="keyword">if</span> l1.next == l2.next:</span><br><span class="line">            <span class="keyword">return</span> l1.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l1 = l1.next</span><br><span class="line">            l2 = l2.next</span><br></pre></td></tr></table></figure><p>修改了一下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">node</span><span class="params">(l1, l2)</span>:</span></span><br><span class="line">    length1, length2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment"># 求两个链表长度</span></span><br><span class="line">    <span class="keyword">while</span> l1.next:</span><br><span class="line">        l1 = l1.next<span class="comment">#尾节点</span></span><br><span class="line">        length1 += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l2.next:</span><br><span class="line">        l2 = l2.next<span class="comment">#尾节点</span></span><br><span class="line">        length2 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#如果相交</span></span><br><span class="line">    <span class="keyword">if</span> l1.next == l2.next:</span><br><span class="line">        <span class="comment"># 长的链表先走</span></span><br><span class="line">        <span class="keyword">if</span> length1 &gt; length2:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(length1 - length2):</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">return</span> l1<span class="comment">#返回交点</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(length2 - length1):</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            <span class="keyword">return</span> l2<span class="comment">#返回交点</span></span><br><span class="line">    <span class="comment"># 如果不相交</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>思路: <a href="http://humaoli.blog.163.com/blog/static/13346651820141125102125995/" target="_blank" rel="noopener">http://humaoli.blog.163.com/blog/static/13346651820141125102125995/</a></p><h2 id="10-二分查找"><a href="#10-二分查找" class="headerlink" title="10 二分查找"></a>10 二分查找</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(list,item)</span>:</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = len(list)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> low&lt;=high:</span><br><span class="line">        mid = (low+high)/<span class="number">2</span></span><br><span class="line">        guess = list[mid]</span><br><span class="line">        <span class="keyword">if</span> guess&gt;item:</span><br><span class="line">            high = mid<span class="number">-1</span></span><br><span class="line">        <span class="keyword">elif</span> guess&lt;item:</span><br><span class="line">            low = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">mylist = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line"><span class="keyword">print</span> binary_search(mylist,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>参考: <a href="http://blog.csdn.net/u013205877/article/details/76411718" target="_blank" rel="noopener">http://blog.csdn.net/u013205877/article/details/76411718</a></p><h2 id="11-快排"><a href="#11-快排" class="headerlink" title="11 快排"></a>11 快排</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(list)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(list)&lt;<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> list</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        midpivot = list[<span class="number">0</span>]</span><br><span class="line">        lessbeforemidpivot = [i <span class="keyword">for</span> i <span class="keyword">in</span> list[<span class="number">1</span>:] <span class="keyword">if</span> i&lt;=midpivot]</span><br><span class="line">        biggerafterpivot = [i <span class="keyword">for</span> i <span class="keyword">in</span> list[<span class="number">1</span>:] <span class="keyword">if</span> i &gt; midpivot]</span><br><span class="line">        finallylist = quicksort(lessbeforemidpivot)+[midpivot]+quicksort(biggerafterpivot)</span><br><span class="line">        <span class="keyword">return</span> finallylist</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> quicksort([<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>])</span><br></pre></td></tr></table></figure><blockquote><p> 更多排序问题可见：<a href="http://blog.csdn.net/mrlevo520/article/details/77829204" target="_blank" rel="noopener">数据结构与算法-排序篇-Python描述</a></p></blockquote><h2 id="12-找零问题"><a href="#12-找零问题" class="headerlink" title="12 找零问题"></a>12 找零问题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="comment">#values是硬币的面值values = [ 25, 21, 10, 5, 1]</span></span><br><span class="line"><span class="comment">#valuesCounts   钱币对应的种类数</span></span><br><span class="line"><span class="comment">#money  找出来的总钱数</span></span><br><span class="line"><span class="comment">#coinsUsed   对应于目前钱币总数i所使用的硬币数目</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(values,valuesCounts,money,coinsUsed)</span>:</span></span><br><span class="line">    <span class="comment">#遍历出从1到money所有的钱数可能</span></span><br><span class="line">    <span class="keyword">for</span> cents <span class="keyword">in</span> range(<span class="number">1</span>,money+<span class="number">1</span>):</span><br><span class="line">        minCoins = cents</span><br><span class="line">        <span class="comment">#把所有的硬币面值遍历出来和钱数做对比</span></span><br><span class="line">        <span class="keyword">for</span> kind <span class="keyword">in</span> range(<span class="number">0</span>,valuesCounts):</span><br><span class="line">            <span class="keyword">if</span> (values[kind] &lt;= cents):</span><br><span class="line">                temp = coinsUsed[cents - values[kind]] +<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> (temp &lt; minCoins):</span><br><span class="line">                    minCoins = temp</span><br><span class="line">        coinsUsed[cents] = minCoins</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'面值:&#123;0&#125;的最少硬币使用数为:&#123;1&#125;'</span>.format(cents, coinsUsed[cents]))</span><br></pre></td></tr></table></figure><p>思路: <a href="http://blog.csdn.net/wdxin1322/article/details/9501163" target="_blank" rel="noopener">http://blog.csdn.net/wdxin1322/article/details/9501163</a></p><p>方法: <a href="http://www.cnblogs.com/ChenxofHit/archive/2011/03/18/1988431.html" target="_blank" rel="noopener">http://www.cnblogs.com/ChenxofHit/archive/2011/03/18/1988431.html</a></p><h2 id="13-广度遍历和深度遍历二叉树"><a href="#13-广度遍历和深度遍历二叉树" class="headerlink" title="13 广度遍历和深度遍历二叉树"></a>13 广度遍历和深度遍历二叉树</h2><p>给定一个数组，构建二叉树，并且按层次打印这个二叉树</p><h2 id="14-二叉树节点"><a href="#14-二叉树节点" class="headerlink" title="14 二叉树节点"></a>14 二叉树节点</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data, left=None, right=None)</span>:</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line">tree = Node(<span class="number">1</span>, Node(<span class="number">3</span>, Node(<span class="number">7</span>, Node(<span class="number">0</span>)), Node(<span class="number">6</span>)), Node(<span class="number">2</span>, Node(<span class="number">5</span>), Node(<span class="number">4</span>)))</span><br></pre></td></tr></table></figure><h2 id="15-层次遍历"><a href="#15-层次遍历" class="headerlink" title="15 层次遍历"></a>15 层次遍历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lookup</span><span class="params">(root)</span>:</span></span><br><span class="line">    row = [root]</span><br><span class="line">    <span class="keyword">while</span> row:</span><br><span class="line">        print(row)</span><br><span class="line">        row = [kid <span class="keyword">for</span> item <span class="keyword">in</span> row <span class="keyword">for</span> kid <span class="keyword">in</span> (item.left, item.right) <span class="keyword">if</span> kid]</span><br></pre></td></tr></table></figure><h2 id="16-深度遍历"><a href="#16-深度遍历" class="headerlink" title="16 深度遍历"></a>16 深度遍历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deep</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">print</span> root.data</span><br><span class="line">    deep(root.left)</span><br><span class="line">    deep(root.right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    lookup(tree)</span><br><span class="line">    deep(tree)</span><br></pre></td></tr></table></figure><h2 id="17-前中后序遍历"><a href="#17-前中后序遍历" class="headerlink" title="17 前中后序遍历"></a>17 前中后序遍历</h2><p>深度遍历改变顺序就OK了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="comment">#二叉树的遍历</span></span><br><span class="line"><span class="comment">#简单的二叉树节点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,value,left,right)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"><span class="comment">#中序遍历:遍历左子树,访问当前节点,遍历右子树</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mid_travelsal</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        mid_travelsal(root.left)</span><br><span class="line">    <span class="comment">#访问当前节点</span></span><br><span class="line">    print(root.value)</span><br><span class="line">    <span class="keyword">if</span> root.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        mid_travelsal(root.right)</span><br><span class="line"></span><br><span class="line"><span class="comment">#前序遍历:访问当前节点,遍历左子树,遍历右子树</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pre_travelsal</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> (root.value)</span><br><span class="line">    <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        pre_travelsal(root.left)</span><br><span class="line">    <span class="keyword">if</span> root.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        pre_travelsal(root.right)</span><br><span class="line"></span><br><span class="line"><span class="comment">#后续遍历:遍历左子树,遍历右子树,访问当前节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post_trvelsal</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        post_trvelsal(root.left)</span><br><span class="line">    <span class="keyword">if</span> root.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        post_trvelsal(root.right)</span><br><span class="line">    <span class="keyword">print</span> (root.value)</span><br></pre></td></tr></table></figure><h2 id="18-求最大树深"><a href="#18-求最大树深" class="headerlink" title="18 求最大树深"></a>18 求最大树深</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="19-求两棵树是否相同"><a href="#19-求两棵树是否相同" class="headerlink" title="19 求两棵树是否相同"></a>19 求两棵树是否相同</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(p, q)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> p == <span class="keyword">None</span> <span class="keyword">and</span> q == <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">elif</span> p <span class="keyword">and</span> q :</span><br><span class="line">        <span class="keyword">return</span> p.val == q.val <span class="keyword">and</span> isSameTree(p.left,q.left) <span class="keyword">and</span> isSameTree(p.right,q.right)</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h2 id="20-前序中序求后序"><a href="#20-前序中序求后序" class="headerlink" title="20 前序中序求后序"></a>20 前序中序求后序</h2><p>推荐: <a href="http://blog.csdn.net/hinyunsin/article/details/6315502" target="_blank" rel="noopener">http://blog.csdn.net/hinyunsin/article/details/6315502</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rebuild</span><span class="params">(pre, center)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pre:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    cur = Node(pre[<span class="number">0</span>])</span><br><span class="line">    index = center.index(pre[<span class="number">0</span>])</span><br><span class="line">    cur.left = rebuild(pre[<span class="number">1</span>:index + <span class="number">1</span>], center[:index])</span><br><span class="line">    cur.right = rebuild(pre[index + <span class="number">1</span>:], center[index + <span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> cur</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deep</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    deep(root.left)</span><br><span class="line">    deep(root.right)</span><br><span class="line">    <span class="keyword">print</span> root.data</span><br></pre></td></tr></table></figure><h2 id="21-单链表逆置"><a href="#21-单链表逆置" class="headerlink" title="21 单链表逆置"></a>21 单链表逆置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data=None, next=None)</span>:</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.next = next</span><br><span class="line"></span><br><span class="line">link = Node(<span class="number">1</span>, Node(<span class="number">2</span>, Node(<span class="number">3</span>, Node(<span class="number">4</span>, Node(<span class="number">5</span>, Node(<span class="number">6</span>, Node(<span class="number">7</span>, Node(<span class="number">8</span>, Node(<span class="number">9</span>)))))))))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rev</span><span class="params">(link)</span>:</span></span><br><span class="line">    pre = link</span><br><span class="line">    cur = link.next</span><br><span class="line">    pre.next = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        tmp = cur.next</span><br><span class="line">        cur.next = pre</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = tmp</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line"></span><br><span class="line">root = rev(link)</span><br><span class="line"><span class="keyword">while</span> root:</span><br><span class="line">    <span class="keyword">print</span> root.data</span><br><span class="line">    root = root.next</span><br></pre></td></tr></table></figure><p>思路: <a href="http://blog.csdn.net/feliciafay/article/details/6841115" target="_blank" rel="noopener">http://blog.csdn.net/feliciafay/article/details/6841115</a></p><p>方法: <a href="http://www.xuebuyuan.com/2066385.html?mobile=1" target="_blank" rel="noopener">http://www.xuebuyuan.com/2066385.html?mobile=1</a></p><h2 id="22-两个字符串是否是变位词"><a href="#22-两个字符串是否是变位词" class="headerlink" title="22 两个字符串是否是变位词"></a>22 两个字符串是否是变位词</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Anagram</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @:param s1: The first string</span></span><br><span class="line"><span class="string">    @:param s2: The second string</span></span><br><span class="line"><span class="string">    @:return true or false</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Solution1</span><span class="params">(s1,s2)</span>:</span></span><br><span class="line">        alist = list(s2)</span><br><span class="line"></span><br><span class="line">        pos1 = <span class="number">0</span></span><br><span class="line">        stillOK = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> pos1 &lt; len(s1) <span class="keyword">and</span> stillOK:</span><br><span class="line">            pos2 = <span class="number">0</span></span><br><span class="line">            found = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">while</span> pos2 &lt; len(alist) <span class="keyword">and</span> <span class="keyword">not</span> found:</span><br><span class="line">                <span class="keyword">if</span> s1[pos1] == alist[pos2]:</span><br><span class="line">                    found = <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pos2 = pos2 + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> found:</span><br><span class="line">                alist[pos2] = <span class="keyword">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stillOK = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">            pos1 = pos1 + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stillOK</span><br><span class="line"></span><br><span class="line">    print(Solution1(<span class="string">'abcd'</span>,<span class="string">'dcba'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Solution2</span><span class="params">(s1,s2)</span>:</span></span><br><span class="line">        alist1 = list(s1)</span><br><span class="line">        alist2 = list(s2)</span><br><span class="line"></span><br><span class="line">        alist1.sort()</span><br><span class="line">        alist2.sort()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        pos = <span class="number">0</span></span><br><span class="line">        matches = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> pos &lt; len(s1) <span class="keyword">and</span> matches:</span><br><span class="line">            <span class="keyword">if</span> alist1[pos] == alist2[pos]:</span><br><span class="line">                pos = pos + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                matches = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> matches</span><br><span class="line"></span><br><span class="line">    print(Solution2(<span class="string">'abcde'</span>,<span class="string">'edcbg'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Solution3</span><span class="params">(s1,s2)</span>:</span></span><br><span class="line">        c1 = [<span class="number">0</span>]*<span class="number">26</span></span><br><span class="line">        c2 = [<span class="number">0</span>]*<span class="number">26</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s1)):</span><br><span class="line">            pos = ord(s1[i])-ord(<span class="string">'a'</span>)</span><br><span class="line">            c1[pos] = c1[pos] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s2)):</span><br><span class="line">            pos = ord(s2[i])-ord(<span class="string">'a'</span>)</span><br><span class="line">            c2[pos] = c2[pos] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        stillOK = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">while</span> j&lt;<span class="number">26</span> <span class="keyword">and</span> stillOK:</span><br><span class="line">            <span class="keyword">if</span> c1[j] == c2[j]:</span><br><span class="line">                j = j + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stillOK = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stillOK</span><br><span class="line"></span><br><span class="line">    print(Solution3(<span class="string">'apple'</span>,<span class="string">'pleap'</span>))</span><br></pre></td></tr></table></figure><h2 id="23-动态规划问题"><a href="#23-动态规划问题" class="headerlink" title="23 动态规划问题"></a>23 动态规划问题</h2><blockquote><p> 可参考：<a href="http://blog.csdn.net/mrlevo520/article/details/75676160" target="_blank" rel="noopener">动态规划(DP)的整理-Python描述</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/GnSZkv7.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;!-- markdown-toc start - Don&#39;t edit this section. Run M-x markdown-toc-generate-to
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>“我的博客”</title>
    <link href="https://mvp099.github.io/2018/03/22/%E2%80%9C%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E2%80%9D/"/>
    <id>https://mvp099.github.io/2018/03/22/“我的博客”/</id>
    <published>2018-03-22T15:10:18.000Z</published>
    <updated>2018-03-23T04:44:51.513Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/ltclGHf.png" alt=""></p><p>What？</p><ol><li>什么是Python？</li></ol><p>Python是一种编程语言，它有对象、模块、线程、异常处理和自动内存管理。可以加入与其他语言的对比。下面是回答这一问题的几个关键点：<a id="more"></a></p><p>a. Python是一种解释型语言，python代码在运行之前不需要编译。</p><p>b. Python是动态类型语言，在声明变量时，不需要说明变量的类型。</p><p>c. Python适合面向对象的编程，因为它支持通过组合与继承的方式定义类。</p><p>d. 在Python语言中，函数是第一类对象。</p><p>e. Python代码编写快，但是运行速度比编译语言通常要慢。</p><p>f. Python用途广泛，常被用作“胶水语言”，可帮助其他语言和组件改善运行状况。</p><p>g. 使用Python，程序员可以专注于算法和数据结构的设计，而不用处理底层的细节。</p><ol><li>什么是Python自省？</li></ol><p>python自省是python具有的一种能力，使程序员面向对象的语言所写的程序在运行时,能够获得对象的类python型。Python是一种解释型语言。为程序员提供了极大的灵活性和控制力。</p><ol><li>什么是PEP 8？</li></ol><p>PEP8是一种编程规范，内容是一些关于如何让你的程序更具可读性的建议。</p><ol><li>什么是pickling和unpickling？</li></ol><p>Pickle模块读入任何Python对象，将它们转换成字符串，然后使用dump函数将其转储到一个文件中——这个过程叫做pickling。反之从存储的字符串文件中提取原始Python对象的过程，叫做unpickling。</p><ol><li>什么是Python装饰器？</li></ol><p>Python装饰器是Python中的特有变动，可以使修改函数变得更容易。</p><ol><li>什么是Python的命名空间？</li></ol><p>在Python中，所有的名字都存在于一个空间中，它们在该空间中存在和被操作——这就是命名空间。它就好像一个盒子，每一个变量名字都对应装着一个对象。当查询变量的时候，会从该盒子里面寻找相应的对象。</p><ol><li>什么是字典推导式和列表推导式？</li></ol><p>它们是可以轻松创建字典和列表的语法结构。</p><ol><li>Lambda函数是什么？</li></ol><p>这是一个常被用于代码中的单个表达式的匿名函数。</p><ol><li>*args，**kwargs？参数是什么？</li></ol><p>如果我们不确定要往函数中传入多少个参数，或者我们想往函数中以列表和元组的形式传参数时，那就使要用*args；如果我们不知道要往函数中传入多少个关键词参数，或者想传入字典的值作为关键词参数时，那就要使用**kwargs。</p><ol><li>什么是Pass语句？</li></ol><p>Pass是一个在Python中不会被执行的语句。在复杂语句中，如果一个地方需要暂时被留白，它常常被用于占位符。</p><ol><li>unittest是什么？</li></ol><p>在Python中，unittest是Python中的单元测试框架。它拥有支持共享搭建、自动测试、在测试中暂停代码、将不同测试迭代成一组，等等的功能。</p><ol><li>构造器是什么？</li></ol><p>构造器是实现迭代器的一种机制。它功能的实现依赖于yield表达式，除此之外它跟普通的函数没有两样。</p><ol><li>doc string是什么？</li></ol><p>Python中文档字符串被称为docstring，它在Python中的作用是为函数、模块和类注释生成文档。</p><ol><li>负索引是什么？</li></ol><p>Python中的序列索引可以是正也可以是负。如果是正索引，0是序列中的第一个索引，1是第二个索引。如果是负索引，（-1）是最后一个索引而（-2）是倒数第二个索引。</p><ol><li>模块和包是什么？</li></ol><p>在Python中，模块是搭建程序的一种方式。每一个Python代码文件都是一个模块，并可以引用其他的模块，比如对象和属性。</p><p>一个包含许多Python代码的文件夹是一个包。一个包可以包含模块和子文件夹。</p><ol><li>垃圾回收是什么？</li></ol><p>在Python中，为了解决内存泄露问题，采用了对象引用计数，并基于引用计数实现自动垃圾回收。</p><ol><li>CSRF是什么？</li></ol><p>CSRF是伪造客户端请求的一种攻击，CSRF的英文全称是Cross Site Request Forgery，字面上的意思是跨站点伪造请求。</p><p>How？</p><ol><li>如何让你的程序更具可读性？</li></ol><p>适当地加入非前导空格，适当的空行以及一致的命名。</p><ol><li>Python是如何被解释的？</li></ol><p>Python是一种解释性语言，它的源代码可以直接运行。Python解释器会将源代码转换成中间语言，之后再翻译成机器码再执行。</p><ol><li>如何在Python中拷贝一个对象？</li></ol><p>如果要在Python中拷贝一个对象，大多时候你可以用copy.copy()或者copy.deepcopy()。但并不是所有的对象都可以被拷贝。</p><ol><li>如何用Python删除一个文件？</li></ol><p>使用函数os.remove(“file”)</p><ol><li>如何将一个数字转换成一个字符串？</li></ol><p>你可以使用自带函数str()将一个数字转换为字符串。如果你想要八进制或者十六进制数，可以用oct()或hex()。</p><ol><li>Python是如何进行内存管理的？</li></ol><p>Python的内存管理是由私有heap空间管理的。所有的Python对象和数据结构都在一个私有heap中。程序员没有访问该heap的权限，只有解释器才能对它进行操作。为Python的heap空间分配内存是由Python的内存管理模块进行的，其核心API会提供一些访问该模块的方法供程序员使用。Python有自带的垃圾回收系统，它回收并释放没有被使用的内存，让它们能够被其他程序使用。</p><ol><li>如何实现tuple和list的转换？</li></ol><p>以list作为参数将tuple类初始化，将返回tuple类型</p><p>以tuple作为参数将list类初始化，将返回list类型</p><ol><li>Python里面如何生成随机数？</li></ol><p>在python中用于生成随机数的模块是random，在使用前需要import. 如下例子可以酌情列举：</p><p>random.random()：生成一个0-1之间的随机浮点数</p><p>random.uniform(a, b)：生成[a,b]之间的浮点数</p><p>random.randint(a, b)：生成[a,b]之间的整数</p><p>random.randrange(a, b, step)：在指定的集合[a,b)中，以step为基数随机取一个数</p><p>random.choice(sequence)：从特定序列中随机取一个元素，这里的序列可以是字符串，列表，元组等</p><ol><li>如何在一个function里面设置一个全局的变量</li></ol><p>如果要给全局变量在一个函数里赋值，必须使用global语句。global VarName的表达式会告诉Python， VarName是一个全局变量，这样Python就不会在局部命名空间里寻找这个变量了</p><ol><li>Python如何实现单例模式？其他23种设计模式python如何实现？</li></ol><p>单例模式主要有四种方法：<strong>new</strong>、共享属性、装饰器、import。</p><p>其他23种设计模式可基本分为创建型、结构型和行为型模式。</p><p>创建模式，提供实例化的方法，为适合的状况提供相应的对象创建方法。</p><p>结构化模式，通常用来处理实体之间的关系，使得这些实体能够更好地协同工作。</p><p>行为模式，用于在不同的实体建进行通信，为实体之间的通信提供更容易，更灵活的通信方法。</p><p>各模式的实现可根据其特点编写代码（限于篇幅，此处不做示例）</p><ol><li>如何判断单向链表中是否有环</li></ol><p>首先遍历链表，寻找是否有相同地址，借此判断链表中是否有环。如果程序进入死循环，则需要一块空间来存储指针，遍历新指针时将其和储存的旧指针比对，若有相同指针，则该链表有环，否则将这个新指针存下来后继续往下读取，直到遇见NULL，这说明这个链表无环。</p><ol><li>如何遍历一个内部未知的文件夹？</li></ol><p>常用的有以下这几种办法：os.path.walk()，os.walk()，listdir</p><ol><li>mysql数据库如何分区、分表？</li></ol><p>分表可以通过三种方式：mysql集群、自定义规则和merge存储引擎。</p><p>分区有四类：</p><p>RANGE 分区：基于属于一个给定连续区间的列值，把多行分配给分区。</p><p>LIST 分区：类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择。</p><p>HASH分区：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL 中有效的、产生非负整数值的任何表达式。</p><p>KEY 分区：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL 服务器提供其自身的哈希函数。必须有一列或多列包含整数值。</p><ol><li>如何对查询命令进行优化？</li></ol><p>a. 应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索。</p><p>b. 应尽量避免在 where 子句中对字段进行 null 值判断，避免使用!=或&lt;&gt;操作符，避免使用 or 连接条件，或在where子句中使用参数、对字段进行表达式或函数操作，否则会导致权标扫描</p><p>c. 不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p><p>d. 使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用。</p><p>e. 很多时候可考虑用 exists 代替 in</p><p>f. 尽量使用数字型字段</p><p>g. 尽可能的使用 varchar/nvarchar 代替 char/nchar</p><p>h. 任何地方都不要使用 select <em> from t ，用具体的字段列表代替“</em>”，不要返回用不到的任何字段。</p><p>i. 尽量使用表变量来代替临时表。</p><p>j. 避免频繁创建和删除临时表，以减少系统表资源的消耗。</p><p>k. 尽量避免使用游标，因为游标的效率较差。</p><p>l. 在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF</p><p>m. 尽量避免大事务操作，提高系统并发能力。</p><p>n. 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p><ol><li>如何理解开源？</li></ol><p>开源，即开放源代码。开源诞生于软件行业，它不仅仅代表软件源代码的开放，本身即意味着自由、共享和充分利用资源。开源是一种精神，是一种文化，如今已经成为软件业发展的大势所趋。</p><ol><li>如何理解MVC/MTV框架？</li></ol><p>MVC就是把Web应用分为模型（M），控制器（C）和视图（V）三层，他们之间以一种插件式的、松耦合的方式连接在一起。MTV模式本质上和MVC是一样的，也是为了各组件间保持松耦合关系，只是定义上有些许不同。</p><ol><li>MSSQL的死锁是如何产生的？</li></ol><p>如下是死锁产生的四个必要条件：</p><p>互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</p><p>请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</p><p>不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</p><p>环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</p><ol><li>Sql注入是如何产生的，如何防止？</li></ol><p>程序开发过程中不注意规范书写sql语句和对特殊字符进行过滤，导致客户端可以通过全局变量POST和GET提交一些sql语句正常执行。产生Sql注入。下面是防止办法：</p><p>a. 过滤掉一些常见的数据库操作关键字，或者通过系统函数来进行过滤。</p><p>b. 在PHP配置文件中将Register_globals=off;设置为关闭状态</p><p>c. SQL语句书写的时候尽量不要省略小引号(tab键上面那个)和单引号</p><p>d. 提高数据库命名技巧，对于一些重要的字段根据程序的特点命名，取不易被猜到的</p><p>e. 对于常用的方法加以封装，避免直接暴漏SQL语句</p><p>f. 开启PHP安全模式：Safe_mode=on;</p><p>g. 打开magic_quotes_gpc来防止SQL注入</p><p>h. 控制错误信息：关闭错误提示信息，将错误信息写到系统日志。</p><p>i. 使用mysqli或pdo预处理。</p><ol><li>xxs如何预防？</li></ol><p>XSS漏洞难以检测，但是为了WEB安全仍需要尽力避免：</p><p>针对反射型和存储型XSS，需要服务端和前端共同预防，针对用户输入的数据做解析和转义，对于前端开发而言，则是善于使用escape，针对data URI内容做正则判断，禁止用户输入非显示信息。</p><p>对于DOM XSS，由于造成XSS的原因在于用户的输入，因此在前端，需要特别注意用户输入源，并对可能造成的XSS的操作需要进行字串转义。</p><ol><li>如何生成共享秘钥？ 如何防范中间人攻击？</li></ol><p>密钥的生成是通过使用全局配置命令完成的：对于不可输出密钥是&lt;crypto key generate rsa label {label string}，而对于可输出密钥则是<crypto key="" generate="" rsa="" exportable="" label="" {label="" string}="">。标记（label）是可选择的；如果没有指定标记，那么密钥名称将是hostname.domain-name。</crypto></p><p>对于中间人的攻击，可以采用如下防范手段：</p><p>a. 通过采用动态ARP检测、DHCP Snooping等控制操作来加强网络基础设施</p><p>b. 采用传输加密</p><p>c. 使用CASBs（云访问安全代理）</p><p>d. 创建RASP（实时应用程序自我保护）</p><p>e. 阻止自签名证书</p><p>f. 强制使用SSL pinning</p><p>g.  安装DAM（数据库活动监控）</p><ol><li>如何管理不同版本的代码？</li></ol><p>进行版本管理。可举例告知如何使用Git（或是其他工具）进行追踪。</p><p>Difference</p><ol><li>数组和元组之间的区别？</li></ol><p>数组在python中叫作列表。列表可以修改，而元组不可以修改，如果元组中仅有一个元素，则要在元素后加上逗号。元组和列表的查询方式一样。元组只可读不可修改，如果程序中的数据不允许修改可用元组。</p><ol><li><em>new</em>和<em>init</em>的区别？</li></ol><p><strong>init</strong>是当实例对象创建完成后被调用的，然后设置对象属性的一些初始值。</p><p><strong>new</strong>是在实例创建之前被调用的，因为它的任务就是创建实例然后返回该实例，是个静态方法。</p><p>也就是，<strong>new</strong>在<strong>init</strong>之前被调用，<strong>new</strong>的返回值（实例）将传递给<strong>init</strong>方法的第一个参数，然后<strong>init</strong>给这个实例设置一些参数。</p><ol><li>Python中单下划线和双下划綫的区别？</li></ol><p>“单下划线” 开始的成员变量叫做保护变量，意思是只有类对象和子类对象自己能访问到这些变量；</p><p>“双下划线” 开始的是私有成员，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据。</p><ol><li>浅拷贝与深拷贝的区别是？</li></ol><p>在python中，对象赋值实际上是对象的引用。浅拷贝，没有拷贝子对象，所以原始数据改变，子对象会改变，而深拷贝，包含对象里面的自对象的拷贝，所以原始对象的改变不会造成深拷贝里任何子元素的改变。</p><ol><li>使用装饰器的单例和使用其他方法的单例，在后续使用中，有何区别？</li></ol><p>Import方法改变了类本身，new方法，但是只是把所有实例对象共享属性，每次产生一个新对象。算作伪单例，共享属性方法实例化了许多个相同属性。所以，装饰器方法最为实用。</p><ol><li>多进程与多线程的区别？</li></ol><p>a. 简而言之,一个程序至少有一个进程，一个进程至少有一个线程。</p><p>b. 线程的划分尺度小于进程，使得多线程程序的并发性高。</p><p>c. 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</p><p>d. 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p><p>e. 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p><ol><li>select和epoll的区别？</li></ol><p>a. select实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。</p><p>b. select每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。</p><ol><li>TCP和UDP的区别？边缘触发和水平触发的区别？</li></ol><p>a. 基本区别：</p><pre><code>基于连接与无连接TCP要求系统资源较多，UDP较少； UDP程序结构较简单 流模式（TCP）与数据报模式(UDP); TCP保证数据正确性，UDP可能丢包 TCP保证数据顺序，UDP不保证 </code></pre><p>b. 编程中的区别</p><pre><code>socket()的参数不同 UDP Server不需要调用listen和accept UDP收发数据用sendto/recvfrom函数 TCP：地址信息在connect/accept时确定 UDP：在sendto/recvfrom函数中每次均 需指定地址信息 UDP：shutdown函数无效</code></pre><ol><li>HTTP连接：get和post的区别？</li></ol><p>GET请求，请求的数据会附加在URL之后，以?分割URL和传输数据，多个参数用&amp;连接。URL的编码格式采用的是ASCII编码，而不是uniclde，即是说所有的非ASCII字符都要编码之后再传输。</p><p>POST请求：POST请求会把请求的数据放置在HTTP请求包的包体中。上面的item=bandsaw就是实际的传输数据。</p><p>因此，GET请求的数据会暴露在地址栏中，而POST请求则不会。</p><ol><li>varchar与char的区别？</li></ol><p>char 长度是固定的，不管你存储的数据是多少他都会都固定的长度。而varchar则处可变长度但他要在总长度上加1字符，这个用来存储位置。所以在处理速度上char要比varchar快速很多，但是对费存储空间，所以对存储不大，但在速度上有要求的可以使用char类型，反之可以用varchar类型。</p><ol><li>BTree索引和hash索引的区别？</li></ol><p>Hash 索引因其结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引。但也有如下明显的缺点：</p><p>a. Hash 索引仅仅能满足”=”,”IN”和”&lt;=&gt;”查询，不能使用范围查询。</p><p>b. Hash 索引无法被用来避免数据的排序操作。</p><p>c. Hash 索引不能利用部分索引键查询。</p><p>d. Hash 索引在任何时候都不能避免表扫描。</p><p>e. Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。</p><ol><li>primary key和unique的区别？</li></ol><p>a. 作为Primary Key的域/域组不能为null，而Unique Key可以。 </p><p>b. 在一个表中只能有一个Primary Key，而多个Unique Key可以同时存在。 </p><p>C. 逻辑设计上讲，Primary Key一般在逻辑设计中用作记录标识，这也是设置Primary Key的本来用意，而Unique Key只是为了保证域/域组的唯一性。 </p><ol><li>ecb和cbc模式有什么区别？</li></ol><p>ECB：是一种基础的加密方式，密文被分割成分组长度相等的块（不足补齐），然后单独一个个加密，一个个输出组成密文。</p><p>CBC：是一种循环模式，前一个分组的密文和当前分组的明文异或操作后再加密，这样做的目的是增强破解难度。ECB和CBC的加密结果是不一样的，两者的模式不同，而且CBC会在第一个密码块运算时加入一个初始化向量。 </p><ol><li>对称加密与非对称加密的区别？</li></ol><p>对称加密，需要对加密和解密使用相同密钥的加密算法。由于其速度快，对称性加密通常在消息发送方需要加密大量数据时使用。所以，对称性加密也称为密钥加密。</p><p>而非对称加密算法需要两个密钥：公开密钥和私有密钥。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。</p><ol><li>Xrange和range的区别？</li></ol><p>range([start,] stop[, step])，根据start与stop指定的范围以及step设定的步长，生成一个序列。xrange 用法与 range 完全相同，所不同的是生成的不是一个list对象，而是一个生成器。要生成很大的数字序列的时候，用xrange会比range性能优很多，因为不需要一上来就开辟一块很大的内存空间。range会直接生成一个list对象，而xrange则不会直接生成一个list，而是每次调用返回其中的一个值。</p><ol><li>os与sys模块的区别？</li></ol><p>前者提供了一种方便的使用操作系统函数的方法。后者提供访问由解释器使用或维护的变量和与解释器进行交互的函数。</p><ol><li>NoSQL和关系数据库的区别？</li></ol><p>a. SQL数据存在特定结构的表中；而NoSQL则更加灵活和可扩展，存储方式可以省是JSON文档、哈希表或者其他方式。</p><p>b. 在SQL中，必须定义好表和字段结构后才能添加数据，例如定义表的主键(primary key)，索引(index),触发器(trigger),存储过程(stored procedure)等。表结构可以在被定义之后更新，但是如果有比较大的结构变更的话就会变得比较复杂。在NoSQL中，数据可以在任何时候任何地方添加，不需要先定义表。</p><p>c. SQL中如果需要增加外部关联数据的话，规范化做法是在原表中增加一个外键，关联外部数据表。而在NoSQL中除了这种规范化的外部数据表做法以外，我们还能用如下的非规范化方式把外部数据直接放到原数据集中，以提高查询效率。缺点也比较明显，更新审核人数据的时候将会比较麻烦。</p><p>d. SQL中可以使用JOIN表链接方式将多个关系数据表中的数据用一条简单的查询语句查询出来。NoSQL暂未提供类似JOIN的查询方式对多个数据集中的数据做查询。所以大部分NoSQL使用非规范化的数据存储方式存储数据。</p><p>e. SQL中不允许删除已经被使用的外部数据，而NoSQL中则没有这种强耦合的概念，可以随时删除任何数据。</p><p>f. SQL中如果多张表数据需要同批次被更新，即如果其中一张表更新失败的话其他表也不能更新成功。这种场景可以通过事务来控制，可以在所有命令完成后再统一提交事务。而NoSQL中没有事务这个概念，每一个数据集的操作都是原子级的。</p><p>g. 在相同水平的系统设计的前提下，因为NoSQL中省略了JOIN查询的消耗，故理论上性能上是优于SQL的。</p><p>Practice</p><p>这种实践操作类题目比较丰富多样，如下几类比较常见：</p><ol><li>补充缺失的代码</li></ol><p>例如：</p><p>def print_directory_contents(sPath):<br>   import os<br>   for sChild in os.listdir(sPath):<br>       sChildPath = os.path.join(sPath,sChild)<br>       if os.path.isdir(sChildPath):<br>           print_directory_contents(sChildPath)<br>       else:<br>           print sChildPath</p><ol><li>下面这段代码的输出结果是什么？请解释。</li></ol><p>例如：</p><p>list1 = [10, ‘a’]list2 = [123]list3 = [10, ‘a’]</p><p>新的默认列表只在函数被定义的那一刻创建一次。当extendList被没有指定特定参数list调用时，这组list的值随后将被使用。这是因为带有默认参数的表达式在函数被定义的时候被计算，不是在调用的时候被计算。</p><ol><li>下面的代码能够运行么？请解释？</li></ol><p>例如：</p><p>能够运行。当key缺失时，执行DefaultDict类，字典的实例将自动实例化这个数列。</p><ol><li>将函数按照执行效率高低排序，并证明自己的答案是正确的。</li></ol><p>例如：</p><p>按执行效率从高到低排列：f2、f1和f3。要证明这个答案是正确的，你应该知道如何分析自己代码的性能。Python中有一个很好的程序分析包，可以满足这个需求。 </p><p>……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/ltclGHf.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;What？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;什么是Python？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Python是一种编程语言，它有对象、模块、线程、异常处理和自动内存管理。可以加入与其他语言的对比。下面是回答这一问题的几个关键点：
    
    </summary>
    
    
      <category term="-Python3.6" scheme="https://mvp099.github.io/tags/Python3-6/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://mvp099.github.io/2018/03/22/hello-world/"/>
    <id>https://mvp099.github.io/2018/03/22/hello-world/</id>
    <published>2018-03-22T10:24:48.853Z</published>
    <updated>2018-03-26T16:47:43.708Z</updated>
    
    <content type="html"><![CDATA[<p>[编程题] 彩色的砖块</p><p>时间限制：1秒</p><p>空间限制：32768K</p><pre><code>小易有一些彩色的砖块。每种颜色由一个大写字母表示。各个颜色砖块看起来都完全一样。现在有一个给定的字符串s,s中每个字符代表小易的某个砖块的颜色。小易想把他所有的砖块排成一行。如果最多存在一对不同颜色的相邻砖块,那么这行砖块就很漂亮的。请你帮助小易计算有多少种方式将他所有砖块排成漂亮的一行。(如果两种方式所对应的砖块颜色序列是相同的,那么认为这两种方式是一样的。)例如: s = “ABAB”,那么小易有六种排列的结果:“AABB”,”ABAB”,”ABBA”,”BAAB”,”BABA”,”BBAA”其中只有”AABB”和”BBAA”满足最多只有一对不同颜色的相邻砖块。</code></pre><p>输入描述:</p><p>输入包括一个字符串s,字符串s的长度length(1 ≤ length ≤ 50),s中的每一个字符都为一个大写字母(A到Z)。</p><pre><code>1</code></pre><p>输出描述:</p><p>输出一个整数,表示小易可以有多少种方式。</p><pre><code>1</code></pre><p>输入例子1:</p><p>ABAB</p><pre><code>1</code></pre><p>输出例子1:</p><p>2</p><pre><code>1</code></pre><p>解题思路</p><pre><code>麻痹，被题目蒙骗了，别以为是要排列啊，你想一下，两种类型的字母，是不是只有..AAABBB..或者…BBBAAA…这两种情况，三个类型字母特么怎么样都会被接触两次以上！如…AABBCC…</code></pre><p>AC代码</p><p>a = raw_input(“”)<br>new = []<br>for i in range(len(a)):<br>    new.append(a[i])<br>if len(set(new)) == 2:<br>    print 2<br>elif len(set(new)) == 1:<br>    print 1<br>else:<br>    print 0</p><pre><code>12345678910</code></pre><p>[编程题] 等差数列</p><p>时间限制：1秒</p><p>空间限制：32768K</p><pre><code>如果一个数列S满足对于所有的合法的i,都有S[i + 1] = S[i] + d, 这里的d也可以是负数和零,我们就称数列S为等差数列。小易现在有一个长度为n的数列x,小易想把x变为一个等差数列。小易允许在数列上做交换任意两个位置的数值的操作,并且交换操作允许交换多次。但是有些数列通过交换还是不能变成等差数列,小易需要判别一个数列是否能通过交换操作变成等差数列</code></pre><p>输入描述:</p><p>输入包括两行,第一行包含整数n(2 ≤ n ≤ 50),即数列的长度。<br>第二行n个元素x<a href="0 ≤ x[i] ≤ 1000">i</a>,即数列中的每个整数。</p><pre><code>12</code></pre><p>输出描述:</p><p>如果可以变成等差数列输出”Possible”,否则输出”Impossible”。</p><pre><code>1</code></pre><p>输入例子1:</p><p>3<br>3 1 2</p><pre><code>12</code></pre><p>输出例子1:</p><p>Possible</p><pre><code>1</code></pre><p>解题思路</p><pre><code>先排个序，然后后者减去前者做个循环，看看每次减出来的值是不是只有一种，一种就等差</code></pre><p>AC代码</p><p>a = int(raw_input(“”))<br>b = map(int,raw_input(“”).split(“ “))<br>c = sorted(b)<br>res = []<br>for i in range(len(c)-1):<br>    res.append(c[i+1]-c[i])<br>if len(set(res)) == 1:<br>    print ‘Possible’<br>else:<br>    print ‘Impossible’</p><pre><code>12345678910</code></pre><p>[编程题] 交错01串</p><p>时间限制：1秒</p><p>空间限制：32768K</p><pre><code>如果一个01串任意两个相邻位置的字符都是不一样的,我们就叫这个01串为交错01串。例如: “1”,”10101”,”0101010”都是交错01串。小易现在有一个01串s,小易想找出一个最长的连续子串,并且这个子串是一个交错01串。小易需要你帮帮忙求出最长的这样的子串的长度是多少。</code></pre><p>输入描述:</p><p>输入包括字符串s,s的长度length(1 ≤ length ≤ 50),字符串中只包含’0’和’1’</p><pre><code>1</code></pre><p>输出描述:</p><p>输出一个整数,表示最长的满足要求的子串长度。</p><pre><code>1</code></pre><p>输入例子1:</p><p>111101111</p><pre><code>1</code></pre><p>输出例子1:</p><p>3</p><pre><code>1</code></pre><p>解题思路</p><pre><code>后者比较前者，如果字符串相同类型，那就重新计数，如果不同类型，且每次都要不同才符合要求，注意最后一点就是考虑一下全值一致的情况，列表为空单独判断</code></pre><p>AC代码</p><p>a = raw_input(“”)<br>max_ = 1<br>res = []<br>for i in range(1,len(a)):<br>    if a[i] != a[i-1]:<br>        max_ +=1<br>        res.append(max_)<br>    else:<br>        max_ = 1</p><p>if res == []:<br>    print 1<br>else:<br>    print max(res)</p><pre><code>1234567891011121314</code></pre><p>[编程题] 操作序列</p><p>时间限制：2秒</p><p>空间限制：32768K</p><pre><code>小易有一个长度为n的整数序列,a_1,…,a_n。然后考虑在一个空序列b上进行n次以下操作:1、将a_i放入b序列的末尾2、逆置b序列小易需要你计算输出操作n次之后的b序列。</code></pre><p>输入描述:</p><p>输入包括两行,第一行包括一个整数n(2 ≤ n ≤ 2*10^5),即序列的长度。<br>第二行包括n个整数a_i(1 ≤ a_i ≤ 10^9),即序列a中的每个整数,以空格分割。</p><pre><code>12</code></pre><p>输出描述:</p><p>在一行中输出操作n次之后的b序列,以空格分割,行末无空格。</p><pre><code>1</code></pre><p>输入例子1:</p><p>4<br>1 2 3 4</p><pre><code>12</code></pre><p>输出例子1:</p><p>4 2 1 3</p><pre><code>1</code></pre><p>解题思路</p><pre><code>分治思想，虽然我想的比较low，但是这样编写的时候速度快，分成左右两部分，考虑奇偶情况，写出规律，是一个索引递减的情况,还有需要注意的是，它数是一个个落下来的，不是全部落下来之后再挑选数字再逆序的，所以自己走一下流程，就可以观察到索引的变化</code></pre><p>AC代码</p><p>n = int(raw_input(“”))<br>a = map(int,raw_input(“”).split(“ “))<br>b_left = []<br>b_right = []</p><h1 id="这一段虽然可行，但是复杂度太高，AC-60"><a href="#这一段虽然可行，但是复杂度太高，AC-60" class="headerlink" title="这一段虽然可行，但是复杂度太高，AC 60%"></a>这一段虽然可行，但是复杂度太高，AC 60%</h1><p>#for i in a:</p><h1 id="b-append-i"><a href="#b-append-i" class="headerlink" title="b.append(i)"></a>b.append(i)</h1><h1 id="b-reverse"><a href="#b-reverse" class="headerlink" title="b.reverse()"></a>b.reverse()</h1><p>#print “ “.join(map(str,b))</p><p>if len(a)%2 == 0:<br>    b_left = [a[k] for k in range(len(a)-1,0,-2)]<br>    b_right = [a[k] for k in range(0,len(a),2)]<br>else:<br>    b_left = [a[k] for k in range(len(a)-1,-1,-2)]<br>    b_right = [a[k] for k in range(1,len(a),2)]</p><p>print “ “.join(map(str,b_left+b_right))</p><pre><code>12345678910111213141516171819</code></pre><p>[编程题] 独立的小易</p><p>时间限制：1秒</p><p>空间限制：32768K</p><pre><code>小易为了向他的父母表现他已经长大独立了,他决定搬出去自己居住一段时间。一个人生活增加了许多花费: 小易每天必须吃一个水果并且需要每天支付x元的房屋租金。当前小易手中已经有f个水果和d元钱,小易也能去商店购买一些水果,商店每个水果售卖p元。小易为了表现他独立生活的能力,希望能独立生活的时间越长越好,小易希望你来帮他计算一下他最多能独立生活多少天。</code></pre><p>输入描述:</p><p>输入包括一行,四个整数x, f, d, p(1 ≤ x,f,d,p ≤ 2 * 10^9),以空格分割</p><pre><code>1</code></pre><p>输出描述:</p><p>输出一个整数, 表示小易最多能独立生活多少天。</p><pre><code>1</code></pre><p>输入例子1:</p><p>3 5 100 10</p><pre><code>1</code></pre><p>输出例子1:</p><p>11</p><pre><code>1</code></pre><p>解题思路</p><pre><code>考虑水果还没吃完就先房租交不起的情况吧，然后就是小学数学，写个方程求解，okD*x + (D-f)*p =d, 反解D就是能活下去的天数</code></pre><p>AC代码</p><p>x,f,d,p = map(int,raw_input(“”).split(“ “))<br>if d/x &lt; f:<br>    print d/x<br>else:<br>    print (d+f*p)/(x+p)</p><pre><code>12345</code></pre><p>[编程题] 堆棋子</p><p>时间限制：1秒</p><p>空间限制：32768K</p><pre><code>小易将n个棋子摆放在一张无限大的棋盘上。第i个棋子放在第x[i]行y[i]列。同一个格子允许放置多个棋子。每一次操作小易可以把一个棋子拿起并将其移动到原格子的上、下、左、右的任意一个格子中。小易想知道要让棋盘上出现有一个格子中至少有i(1 ≤ i ≤ n)个棋子所需要的最少操作次数.</code></pre><p>输入描述:</p><p>输入包括三行,第一行一个整数n(1 ≤ n ≤ 50),表示棋子的个数<br>第二行为n个棋子的横坐标x<a href="1 ≤ x[i] ≤ 10^9">i</a><br>第三行为n个棋子的纵坐标y<a href="1 ≤ y[i] ≤ 10^9">i</a></p><pre><code>123</code></pre><p>输出描述:</p><p>输出n个整数,第i个表示棋盘上有一个格子至少有i个棋子所需要的操作数,以空格分割。行末无空格</p><p>如样例所示:<br>对于1个棋子: 不需要操作<br>对于2个棋子: 将前两个棋子放在(1, 1)中<br>对于3个棋子: 将前三个棋子放在(2, 1)中<br>对于4个棋子: 将所有棋子都放在(3, 1)中</p><pre><code>1234567</code></pre><p>输入例子1:</p><p>4<br>1 2 4 9<br>1 1 1 1</p><pre><code>123</code></pre><p>输出例子1:</p><p>0 1 3 10</p><pre><code>1</code></pre><p>解题思路</p><pre><code>对于一个k,我们找一个坐标(x, y)让k个棋子距离这个坐标的曼哈顿距离之和最小。注意到x和y其实是独立的,考虑枚举棋盘上所有可能得坐标(x[i], y[j]),计算这个坐标到所有棋子的距离分别是多少,然后维护k个棋子对于这个坐标最小曼哈顿距离和即可。—这是抄别人的分析，我自己还在考虑这个问题，他们都用暴力枚举的方法都可行，我得方法中，取了棋子落的上下边界进行遍历，然后有种knn的思想混杂在里面，代码没问题，但是内存超了，后续我再想想</code></pre><p>AC 60%，内存超了</p><p>n = int(raw_input(“”))<br>x = map(int,raw_input(“”).split(“ “))<br>y = map(int,raw_input(“”).split(“ “))<br>gps = zip(x,y)</p><p>guess = []<br>for i in xrange(min(x),max(x)+1):<br>    for j in xrange(min(y),max(y)+1):<br>        guess.append((i,j))</p><p>result = []<br>for i in xrange(1,n+1):<br>    res = []<br>    for j in guess:<br>        res.append(sum(sorted(map(lambda x:abs(x[0]-j[0])+abs(x[1]-j[1]),gps))[:i]))<br>    result.append(min(res))</p><p>print “ “.join(map(str,result))</p><pre><code>123456789101112131415161718192021</code></pre><p>AC代码</p><p>def ManhattanDistance(x1, y1, x2, y2):<br>    return abs(x1 - x2) + abs(y1 - y2)</p><p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    n = int(input())<br>    x = [int(i.strip()) for i in raw_input().split(‘ ‘)]<br>    y = [int(i.strip()) for i in raw_input().split(‘ ‘)]<br>    ans = [10 *<em> 10] </em> n<br>    for i in range(n):<br>        for j in range(n):<br>            tmp = []<br>            s = 0<br>            for k in range(n):<br>                tmp.append(ManhattanDistance(x[i], y[j], x[k], y[k]))<br>            tmp.sort()<br>            for k in range(n):<br>                s += tmp[k]<br>                ans[k] = min(ans[k], s)<br>    for i in ans:<br>        print i,</p><pre><code>1234567891011121314151617181920</code></pre><p>[编程题] 疯狂队列</p><p>时间限制：1秒</p><p>空间限制：32768K</p><pre><code>小易老师是非常严厉的,它会要求所有学生在进入教室前都排成一列,并且他要求学生按照身高不递减的顺序排列。有一次,n个学生在列队的时候,小易老师正好去卫生间了。学生们终于有机会反击了,于是学生们决定来一次疯狂的队列,他们定义一个队列的疯狂值为每对相邻排列学生身高差的绝对值总和。由于按照身高顺序排列的队列的疯狂值是最小的,他们当然决定按照疯狂值最大的顺序来进行列队。现在给出n个学生的身高,请计算出这些学生列队的最大可能的疯狂值。小易老师回来一定会气得半死。</code></pre><p>输入描述:</p><p>输入包括两行,第一行一个整数n(1 ≤ n ≤ 50),表示学生的人数<br>第二行为n个整数h<a href="1 ≤ h[i] ≤ 1000">i</a>,表示每个学生的身高</p><pre><code>12</code></pre><p>输出描述:</p><p>输出一个整数,表示n个学生列队可以获得的最大的疯狂值。</p><p>如样例所示:<br>当队列排列顺序是: 25-10-40-5-25, 身高差绝对值的总和为15+30+35+20=100。<br>这是最大的疯狂值了。</p><pre><code>12345</code></pre><p>输入例子1:</p><p>5<br>5 10 25 40 25</p><pre><code>12</code></pre><p>输出例子1:</p><p>100</p><pre><code>1</code></pre><p>解题思路</p><pre><code>先排序，挑选中间值，然后左右两边交替换值，重新进一个队列里面。你想象一下，如何使交替的人差值最大，可以考虑对称的思想，最大的最小的，然后和次小的，然后和次大的。。。。</code></pre><p>AC代码</p><p>n = int(raw_input(“”))<br>line = map(int ,raw_input(“”).split(“ “))<br>line.sort()<br>mid = len(line)/2<br>left = line[0:mid]<br>right = line[mid+1:]<br>newline = []</p><p>def sumlist(list_):<br>    res = 0<br>    for i in range(1,len(list_)):<br>        res +=abs(list_[i]-list_[i-1])<br>    return res</p><p>if len(line)%2 == 1:<br>    while left and right:<br>        newline.append(right.pop(0))<br>        newline.append(left.pop())<br>    newline.append(line[mid])<br>    print sumlist(newline)</p><p>else:<br>    while left and right:<br>        newline.append(left.pop())<br>        newline.append(right.pop(0))<br>    newline.append(left.pop())<br>    newline.append(line[mid])<br>    print sumlist(newline)</p><pre><code>12345678910111213141516171819202122232425262728</code></pre><p>[编程题] 小易喜欢的数列</p><p>时间限制：1秒</p><p>空间限制：32768K</p><pre><code>小易非常喜欢拥有以下性质的数列:1、数列的长度为n2、数列中的每个数都在1到k之间(包括1和k)3、对于位置相邻的两个数A和B(A在B前),都满足(A &lt;= B)或(A mod B != 0)(满足其一即可)例如,当n = 4, k = 7那么{1,7,7,2},它的长度是4,所有数字也在1到7范围内,并且满足第三条性质,所以小易是喜欢这个数列的但是小易不喜欢{4,4,4,2}这个数列。小易给出n和k,希望你能帮他求出有多少个是他会喜欢的数列。</code></pre><p>输入描述:</p><p>输入包括两个整数n和k(1 ≤ n ≤ 10, 1 ≤ k ≤ 10^5)</p><pre><code>1</code></pre><p>输出描述:</p><p>输出一个整数,即满足要求的数列个数,因为答案可能很大,输出对1,000,000,007取模的结果。</p><pre><code>1</code></pre><p>输入例子1:</p><p>2 2</p><pre><code>1</code></pre><p>输出例子1:</p><p>3</p><pre><code>1</code></pre><p>AC代码</p><p>目前，python，我特么AC不出来啊，求助</p><p>1.<br>一种双核CPU的两个核能够同时的处理任务，现在有n个已知数据量的任务需要交给CPU处理，假设已知CPU的每个核1秒可以处理1kb，每个核同时只能处理一项任务。n个任务可以按照任意顺序放入CPU进行处理，现在需要设计一个方案让CPU处理完这批任务所需的时间最少，求这个最小的时间。<br>输入描述:</p><p>输入包括两行：<br>第一行为整数n(1 ≤ n ≤ 50)<br>第二行为n个整数length<a href="1024 ≤ length[i] ≤ 4194304">i</a>，表示每个任务的长度为length[i]kb，每个数均为1024的倍数。</p><p>输出描述:</p><p>输出一个整数，表示最少需要处理的时间</p><p>输入例子:</p><p>5<br>3072 3072 7168 3072 1024</p><p>输出例子:</p><p>9216</p><p>个人思路：</p><p>1.选择最小的 2 个任务，2 个cup开始对这两个任务进行处理<br>  1.1.如果两个同时完成，则找剩下任务中最小的 2 个任务，继续开始任务处理<br>  1.2.直到剩余任务量为 1 个或者 2 个<br>  2.1.如果一个任务完成，则找剩下任务中最小的 1 个任务，继续开始任务处理</p><p>经过以上思考，我开始着手写代码，最终测试结果为 30% 通过率。</p><p>也是从这道题的正确代码得到教训，我自己写的代码提高的空间太大了。一是对待问题选择的思路，二是代码的简洁性，既然是 python，为什么不发挥它的优势呢？<br>正确结果 (牛客网 id：Mr.Mary)：</p><p>n=int(raw_input())</p><p>arr=[int(i) for i in raw_input().strip().split()]</p><p>h=set(arr)</p><p>for i in arr:</p><pre><code>for j in list(h):    h.add(i+j)</code></pre><p>h=[i for i in h if i&gt;=sum(arr)/2]</p><p>print min(h)<br>巧妙的用到了 python 的 set 和 list。</p><p>先将输入的任务用 set 进行处理，变成无重复的任务集合 h</p><p>然后增加 h 里面处理时间，例如题目中例子增加到最后， h 的结果为</p><p>h set([3072, 7168, 4096, 15360, 19456, 23552, 5120, 8192, 12288, 16384, 20480, 24576, 1024, 6144, 9216, 13312, 17408, 21504, 2048, 11264, 10240, 14336, 18432])</p><p>两个 cup，以输入的任务时间总和除以 2 为基准对 h 进行过滤，最后再取出最小的值，即为所需答案。</p><p>关键在于整合任务的时间、以 sum/2 为基准进行时间筛选。</p><p>2.<br>终于到周末啦！小易走在市区的街道上准备找朋友聚会，突然服务器发来警报,小易需要立即回公司修复这个紧急bug。假设市区是一个无限大的区域，每条街道假设坐标是(X，Y)，小易当前在(0，0)街道，办公室在(gx,gy)街道上。小易周围有多个出租车打车点，小易赶去办公室有两种选择，一种就是走路去公司，另外一种就是走到一个出租车打车点，然后从打车点的位置坐出租车去公司。每次移动到相邻的街道(横向或者纵向)走路将会花费walkTime时间，打车将花费taxiTime时间。小易需要尽快赶到公司去，现在小易想知道他最快需要花费多少时间去公司。<br>输入描述:</p><p>输入数据包括五行:</p><p>第一行为周围出租车打车点的个数n(1 ≤ n ≤ 50)</p><p>第二行为每个出租车打车点的横坐标tX[i] (-10000 ≤ tX[i] ≤ 10000)</p><p>第三行为每个出租车打车点的纵坐标tY[i] (-10000 ≤ tY[i] ≤ 10000)</p><p>第四行为办公室坐标gx,gy(-10000 ≤ gx,gy ≤ 10000),以空格分隔</p><p>第五行为走路时间walkTime(1 ≤ walkTime ≤ 1000)和taxiTime(1 ≤ taxiTime ≤ 1000),以空格分隔</p><p>输出描述:</p><p>输出一个整数表示，小易最快能赶到办公室的时间</p><p>输入例子:</p><p>2<br>-2 -2<br>0 -2<br>-4 -2<br>15 3</p><p>输出例子:</p><p>42</p><p>个人思路：<br>x 或者 y 每变化 +- 1 ,walktime 和 taxitime 都增加一次<br>统计 0,0 到出租车点再到公司的所有时间，取最小值<br>这要分多少种情况啊：16，但这16种情况里面，有几种下面的计算性质都是一样的<br>我的这个思路简单以至于想复杂。<br>正确答案 (牛客网 id：Panzerfaust)：</p><p>while True:</p><pre><code>line = sys.stdin.readline()if line.strip() == &quot;&quot;:    breaknum = int(line)x = [int(var) for var in sys.stdin.readline().split(&quot; &quot;)]y = [int(var) for var in sys.stdin.readline().split(&quot; &quot;)]locate = [int(var) for var in sys.stdin.readline().split(&quot; &quot;)]speed = [int(var) for var in sys.stdin.readline().split(&quot; &quot;)]time = [speed[0] * (abs(locate[0]) + abs(locate[1]))]for i in range(num):    time_num = speed[1] * (abs(x[i] - locate[0]) + abs(y[i] - locate[1])) + speed[0] * (abs(x[i]) + abs(y[i]))    time.append(time_num)print(min(time))</code></pre><p>首先学习的是输入的格式怎么写</p><p>然后，这道题其实是很简单的。注意 abs 的使用，我是对这个考虑太多了。直接就坐标加减即可，别想太多别想太多。</p><p>3.<br>在幼儿园有n个小朋友排列为一个队伍，从左到右一个挨着一个编号为(0~n-1)。其中有一些是男生，有一些是女生，男生用’B’表示，女生用’G’表示。小朋友们都很顽皮，当一个男生挨着的是女生的时候就会发生矛盾。作为幼儿园的老师，你需要让男生挨着女生或者女生挨着男生的情况最少。你只能在原队形上进行调整，每次调整只能让相邻的两个小朋友交换位置，现在需要尽快完成队伍调整，你需要计算出最少需要调整多少次可以让上述情况最少。例如：<br>GGBBG -&gt; GGBGB -&gt; GGGBB<br>这样就使之前的两处男女相邻变为一处相邻，需要调整队形2次<br>输入描述:</p><p>输入数据包括一个长度为n且只包含G和B的字符串.n不超过50.</p><p>输出描述:</p><p>输出一个整数，表示最少需要的调整队伍的次数</p><p>输入例子:</p><p>GGBBG</p><p>输出例子:</p><p>2</p><p>个人思路：</p><ol><li>如果 GB 相邻为 1 次，则 times = 0</li><li>相邻 &gt; 1 次，判断哪个在前，哪一个在后</li><li>移动 设计两个 flag1 = ‘G’, flag2 = ‘B’，前后开始判断<br>结果这一题没有思考下去，就卡在我这个 flag 的选取上了。<br>正确答案 (牛客网 id：Zero2one)：</li></ol><p>‘’’</p><p>只需要计算字符串中第一个’B’移动到第一个位置需要多少次,</p><p>第二个’B’移动到第二个位置需要多少次…依次类推</p><p>同理，对于G也是一样，</p><p>然后取二者中的较小值即可</p><p>‘’’</p><p>import sys</p><p>if <strong>name</strong> == ‘<strong>main</strong>‘:</p><pre><code>S = sys.stdin.readline().strip()s = [i for i in S]loctionsB = loctionsG = icountB = icountG = 0for i in xrange (len(s)):    if s[i] == &apos;B&apos;:        icountB += i - loctionsB        loctionsB += 1    else:        icountG += i - loctionsG        loctionsG += 1print min(icountB,icountG)</code></pre><p>把 B 移到最左边：开始遍历，找到 B，计算移到现在最左边非 B 的位置，记录</p><p>另一个思路（牛客网 id：于晨晨）</p><p>最终目标是将男孩移到最左边，或者将女孩移到最左边。<br>如果有B个男孩，则移到最左边的index分别为：0,1,2…B-1,所以所有index的和为（B-1）*B/2<br>一次遍历，计算目前男孩所在的index的和为sumB，则sumB减去上面的和就是所求的结果。<br>因此只要一次遍历，计算男孩所在的男孩的个数和男孩所在的index的和，求之差就行了。女孩同理。最后求最小值。</p><p>4.<br>易有一个长度为n序列，小易想移除掉里面的重复元素，但是小易想是对于每种元素保留最后出现的那个。小易遇到了困难,希望你来帮助他。<br>输入描述:</p><p>输入包括两行：<br>第一行为序列长度n(1 ≤ n ≤ 50)<br>第二行为n个数sequence<a href="1 ≤ sequence[i] ≤ 1000">i</a>，以空格分隔</p><p>输出描述:</p><p>输出消除重复元素之后的序列，以空格分隔，行末无空格</p><p>输入例子:</p><p>9<br>100 100 100 99 99 99 100 100 100</p><p>输出例子:</p><p>99 100</p><p>个人思路：</p><p>我就从后往前找，当一个元素找到第一个相同的元素后，就把它拿出来，break，下一个。</p><p>测试通过率 20%，题目测试例子以及基本的例子我都符合要求，但还是不正确。</p><p>while n &gt;= len(set(arr))-1:<br>    flag = arr[length-j]<br>    for i in range(length-j-1, -1, -1):<br>        if flag == arr[i]:<br>            del arr[i]<br>            m += 1<br>            length -= 1<br>    n -= m<br>    j += 1</p><p>我就采用立 flag，然后删除，index 变化的方法来完成。</p><p>正确答案(牛客网id：大虫逗你玩)：</p><p>import sys</p><p>num1=int(raw_input().strip())</p><p>num2=map(int,sys.stdin.readline().strip().split())</p><p>num2.reverse()</p><p>num2_new=list(set(num2))</p><p>num2_new.sort(key=num2.index)</p><p>num2_new.reverse()</p><p>for i in num2_new:</p><pre><code>print i,</code></pre><p>这个我看到是用反转，也就是倒着、逆向来，又用到 set，再用 num2 的下标作为关键字进行排序，注意：这里的 num2 是输入的数组反转之后的新数组，因此</p><p>按这个反转的下标排序后，再次对 num2_new 进行反转，下标就返回到原来输入的 num2 咯。</p><p>这里的关键就是，会利用排序 sort 的参数灵活解决问题。</p><p>5.<br>小易拥有一个拥有魔力的手环上面有n个数字(构成一个环),当这个魔力手环每次使用魔力的时候就会发生一种奇特的变化：每个数字会变成自己跟后面一个数字的和(最后一个数字的后面一个数字是第一个),一旦某个位置的数字大于等于100就马上对100取模(比如某个位置变为103,就会自动变为3).现在给出这个魔力手环的构成，请你计算出使用k次魔力之后魔力手环的状态。<br>输入描述:</p><p>输入数据包括两行：<br>第一行为两个整数n(2 ≤ n ≤ 50)和k(1 ≤ k ≤ 2000000000),以空格分隔<br>第二行为魔力手环初始的n个数，以空格分隔。范围都在0至99.</p><p>输出描述:</p><p>输出魔力手环使用k次之后的状态，以空格分隔，行末无空格。</p><p>输入例子:</p><p>3 2<br>1 2 3</p><p>输出例子:</p><p>8 9 7</p><p>个人思路：</p><p>思路 如例子<br> 第一次 + [2, 3, 1] = [3, 5, 4]<br> 第二次 + [5, 4, 3] = [8, 9, 7]</p><p>我还是用自己所掌握的，采用一个临时数组，把第一个元素删除，然后添加到尾部，进行加法。</p><p>转换为列表的下标变化进行解决。结果通过率为 10%，告诉我未在规定时间内完成。怕是循环太复杂了<br>正确答案(牛客网 id：牛客游客)：</p><p>这道题貌似用 python，牛客显示没有人目前做对啊，唯一的这个“牛客游客”，我去跑了一下他的代码，通过率 80%，也是时间超出。</p><p>那不考虑时间，我的现在自己分析起来也是可以的：</p><p>num_times = [int(i) for<br>i in raw_input().strip().split()]</p><p>c = [int(j) for<br>j in raw_input().strip().split()]</p><p>length = num_times[0]</p><p>times = num_times[1]</p><p>l = 0</p><p>while<br>l &lt; times:</p><pre><code>temp = []for</code></pre><p>m in c:</p><pre><code>    temp.append(m)first = temp[0]del temp[0]temp.append(first)o = 0while</code></pre><p>o &lt; length:</p><pre><code>s = temp[o] + c[o]if</code></pre><p>s &gt;= 100:</p><pre><code>        s = int(s) % 100    c[o] = s    o += 1l += 1</code></pre><p>t = ‘ ‘.join(str(i) for<br>i in c)</p><p>print t<br>这道题就算处于还未解决中吧。</p><p>6.<br>现在有n位工程师和6项工作(编号为0至5)，现在给出每个人能够胜任的工作序号表(用一个字符串表示，比如：045，表示某位工程师能够胜任0号，4号，5号工作)。现在需要进行工作安排，每位工程师只能被安排到自己能够胜任的工作当中去，两位工程师不能安排到同一项工作当中去。如果两种工作安排中有一个人被安排在的工作序号不一样就被视为不同的工作安排，现在需要计算出有多少种不同工作安排计划。<br>输入描述:</p><p>输入数据有n+1行：<br>第一行为工程师人数n(1 ≤ n ≤ 6)<br>接下来的n行，每行一个字符串表示第i(1 ≤ i ≤ n)个人能够胜任的工作(字符串不一定等长的)</p><p>输出描述:</p><p>输出一个整数，表示有多少种不同的工作安排方案</p><p>输入例子:</p><p>6<br>012345<br>012345<br>012345<br>012345<br>012345<br>012345</p><p>输出例子:</p><p>720</p><p>个人思路：</p><p>领悟到做题之前，一定要搞明白题目的意思。讲真这一题是十二道题中唯一一个没有明确思路的，不说明确思路，都不知道大致怎么去搞</p><p>摘自牛客解析：</p><ul><li>现在有n位工程师和6项工作(编号为0至5)，</li><li>现在给出每个人能够胜任的工作序号表(用一个字符串表示，比如：045，表示某位工程师能够胜任0号，4号，5号工作)。</li><li>现在需要进行工作安排，每位工程师只能被安排到自己能够胜任的工作当中去，两位工程师不能安排到同一项工作当中去。</li><li>如果两种工作安排中有一个人被安排在的工作序号不一样就被视为不同的工作安排，</li><li>现在需要计算出有多少种不同工作安排计划。</li></ul><p>题目不难，主要是题意太模糊。有两点很可能阻拦了你AC这个题：<br>1、所有工程师都必须有事可做。<br>2、不必所有事都要做。</p><p>#题意有两个地方没说清楚：</p><h1 id="1、一个人只能做一项工程，而不能分饰两角；"><a href="#1、一个人只能做一项工程，而不能分饰两角；" class="headerlink" title="1、一个人只能做一项工程，而不能分饰两角；"></a>1、一个人只能做一项工程，而不能分饰两角；</h1><h1 id="2、有几个工程师，每个工程师有一个工作即满足题意，不用6项工作全部都要有人做。"><a href="#2、有几个工程师，每个工程师有一个工作即满足题意，不用6项工作全部都要有人做。" class="headerlink" title="2、有几个工程师，每个工程师有一个工作即满足题意，不用6项工作全部都要有人做。"></a>2、有几个工程师，每个工程师有一个工作即满足题意，不用6项工作全部都要有人做。</h1><p>正确答案(牛客网 id：zero_python)：</p><p>n = int(raw_input().strip())</p><p>work = [raw_input().strip() for _ in range(n)]</p><p>def dfs(n, work, res):</p><pre><code># 为第n位工程师安排工作ans = 0for ws in work[n]: # 第 n 个工程师能做 work[n]    if ws not in res: # 如果ws没有被安排.         if n == 0: # 如果是最后一个工程师            ans += 1 # 能够安排的数量 +1.         else:            ans += dfs(n-1, work, res+[ws])return ans</code></pre><p>print dfs(n-1, work, [])</p><p>7.<br>小易最近在数学课上学习到了集合的概念,集合有三个特征：1.确定性 2.互异性 3.无序性.<br>小易的老师给了小易这样一个集合：<br>S = { p/q | w ≤ p ≤ x, y ≤ q ≤ z }<br>需要根据给定的w，x，y，z,求出集合中一共有多少个元素。小易才学习了集合还解决不了这个复杂的问题,需要你来帮助他。<br>输入描述:</p><p>输入包括一行：<br>一共4个整数分别是w(1 ≤ w ≤ x)，x(1 ≤ x ≤ 100)，y(1 ≤ y ≤ z)，z(1 ≤ z ≤ 100).以空格分隔</p><p>输出描述:</p><p>输出集合中元素的个数</p><p>输入例子:</p><p>1 10 1 1</p><p>输出例子:</p><p>10</p><p>个人思路：</p><p>例子为： p 为一个数组 [1,2,3,4,5,6,7,8,9,10]</p><pre><code>q 为一个数组 [1]</code></pre><p>集合为： [1,2,3,4,5,6,7,8,9,10]</p><p>就循环 p、q，想除，放入某数组，最后 set 处理一下，over<br>正确答案(自己)：</p><p>wxyz = [int(i) for i in raw_input().strip().split()]</p><p>w = wxyz[0]</p><p>x = wxyz[1]</p><p>y = wxyz[2]</p><p>z = wxyz[3]</p><p>p = []</p><p>q = []</p><p>for i in range(w, x+1, 1):</p><pre><code>p.append(i)</code></pre><p>for j in range(y, z+1, 1):</p><pre><code>q.append(j)</code></pre><p>result = []</p><p>for i in range(0, len(p), 1):</p><pre><code>for j in range(0, len(q), 1):    data = float(p[i]) / q[j]    result.append(data)</code></pre><p>end = set(result)</p><p>print len(end)<br>其实遇见的问题只有一个：分子必须转化成 float 类型！</p><p>8.<br>常规的表达式求值，我们都会根据计算的优先级来计算。比如<em>/的优先级就高于+-。但是小易所生活的世界的表达式规则很简单，从左往右依次计算即可，而且小易所在的世界没有除法，意味着表达式中没有/，只有(+, - 和 </em>)。现在给出一个表达式，需要你帮忙计算出小易所在的世界这个表达式的值为多少<br>输入描述:</p><p>输入为一行字符串，即一个表达式。其中运算符只有-,+,*。参与计算的数字只有0~9.<br>保证表达式都是合法的，排列规则如样例所示。</p><p>输出描述:</p><p>输出一个数，即表达式的值</p><p>输入例子:</p><p>3+5*7</p><p>输出例子:</p><p>56</p><p>个人思路：</p><p>双杀两道题，这一个也不是很难，符号都会是单数下标，数字都是偶数下标，又想起了语法分析器…</p><p>虽然这题我写出来了，用了删除思想。</p><p>if make[0] == plus:<br>    temp += int(number[1])<br>    del make[0]<br>    del number[1]</p><p>但是与现在看到的其他代码相比，还是决定放上人家的。</p><p>正确答案(牛客网 id：你的响亮的名字)：</p><p>expression = raw_input()</p><p>expression = list(expression)</p><p>res = int(expression[0])</p><p>for i in range(len(expression)- 2):</p><pre><code>if expression[i+1] == &apos;+&apos; :    res = res + int(expression[i+2])if expression[i+1] == &apos;-&apos; :    res = res - int(expression[i+2])if expression[i+1] == &apos;*&apos; :    res = res * int(expression[i+2])i= i + 2</code></pre><p>print res<br>简介，清楚，明白，就是从左往右，以此计算。没有考虑太多，值得学习。</p><p>9.<br>小易有一块n*n的棋盘，棋盘的每一个格子都为黑色或者白色，小易现在要用他喜欢的红色去涂画棋盘。小易会找出棋盘中某一列中拥有相同颜色的最大的区域去涂画，帮助小易算算他会涂画多少个棋格。<br>输入描述:</p><p>输入数据包括n+1行：</p><p>第一行为一个整数n(1 ≤ n ≤ 50),即棋盘的大小</p><p>接下来的n行每行一个字符串表示第i行棋盘的颜色，’W’表示白色，’B’表示黑色</p><p>输出描述:</p><p>输出小易会涂画的区域大小</p><p>输入例子:</p><p>3<br>BWW<br>BBB<br>BWB</p><p>输出例子:</p><p>3</p><p>个人思路：</p><p>一开始理解错了，以为求的是一列里面相同颜色最多的棋子，结果后来测试用例 30% ，又讨论了一下，结果明白是：相邻最大相同。</p><p>对于一列，遍历统计<br>正确答案(牛客网 id：Panzerfaust)：</p><p>import sys</p><p>while True:</p><pre><code>line = sys.stdin.readline().strip()if line ==&quot;&quot;:    breaknum = int(line)arr= []for i in range(num):    arr.append(sys.stdin.readline().strip())result = []for i in range(num):    B_count =[1]    for j in range(0,num-1):        if arr[j][i] == arr[j+1][i]:            B_count[-1]+=1        else:            B_count.append(1)    result.append(max(B_count))print(max(result))</code></pre><p>这个是真的妙，统计连续相同的次数放在数组末尾，如果连续相同的被打断了，给数组新加一个统计 1，然后，在新的这个 1 上面，继续进行统计。</p><p>10.<br>小易参与了一个记单词的小游戏。游戏开始系统提供了m个不同的单词，小易记忆一段时间之后需要在纸上写出他记住的单词。小易一共写出了n个他能记住的单词，如果小易写出的单词是在系统提供的，将获得这个单词长度的平方的分数。注意小易写出的单词可能重复，但是对于每个正确的单词只能计分一次。<br>输入描述:</p><p>输入数据包括三行：</p><p>第一行为两个整数n(1 ≤ n ≤ 50)和m(1 ≤ m ≤ 50)。以空格分隔</p><p>第二行为n个字符串，表示小易能记住的单词，以空格分隔，每个单词的长度小于等于50。</p><p>第三行为m个字符串，系统提供的单词，以空格分隔，每个单词的长度小于等于50。</p><p>输出描述:</p><p>输出一个整数表示小易能获得的分数</p><p>输入例子:</p><p>3 4<br>apple orange strawberry<br>strawberry orange grapefruit watermelon</p><p>输出例子:</p><p>136</p><p>个人思路：</p><p>一句话，这个简单啊。使用 list 和 set 就好。但是测试通过 80%<br>正确答案(自己 &amp;&amp; id：啊杜)：</p><p>这是显示的测试通过的</p><p>nm = raw_input().split()</p><p>n = int(nm[0])</p><p>m = int(nm[1])</p><p>string = list(set(raw_input().split()))</p><p>sysStr = raw_input().split()</p><p>result = 0</p><p>for i in string:</p><pre><code>for j in range(m):    if i==sysStr[j]:        result += len(i)**2</code></pre><p>print result</p><p>而我的这次还特意写了一个函数：</p><p>[python] view plain copy</p><pre><code>def score(question, answers):      s = 0      answer = list(set(answers))      for ans in answer:          if ans in question:              s += len(ans)**2      return s  num = [int(i) for i in raw_input().strip().split()]  answer = [a for a in raw_input().strip().split()]  question = [q for q in raw_input().strip().split()]  print score(question, answer)  </code></pre><p>现在一分析，人家那里没用 list 和 set，直接用了 for 循环。</p><p>11.<br>小易有n块砖块，每一块砖块有一个高度。小易希望利用这些砖块堆砌两座相同高度的塔。为了让问题简单，砖块堆砌就是简单的高度相加，某一块砖只能使用在一座塔中一次。小易现在让能够堆砌出来的两座塔的高度尽量高，小易能否完成呢。<br>输入描述:</p><p>输入包括两行：<br>第一行为整数n(1 ≤ n ≤ 50)，即一共有n块砖块<br>第二行为n个整数，表示每一块砖块的高度height[i] (1 ≤ height[i] ≤ 500000)</p><p>输出描述:</p><p>如果小易能堆砌出两座高度相同的塔，输出最高能拼凑的高度，如果不能则输出-1.<br>保证答案不大于500000。</p><p>输入例子:</p><p>3<br>2 3 5</p><p>输出例子:</p><p>5</p><p>个人思路：</p><h1 id="求一个数组中的最大相同相等子序列，判断并输出"><a href="#求一个数组中的最大相同相等子序列，判断并输出" class="headerlink" title="求一个数组中的最大相同相等子序列，判断并输出"></a>求一个数组中的最大相同相等子序列，判断并输出</h1><h1 id="1-数组总和-2-最大值"><a href="#1-数组总和-2-最大值" class="headerlink" title="1.数组总和 / 2 = 最大值"></a>1.数组总和 / 2 = 最大值</h1><h1 id="2-最大值-与-n1-n2-…-n-1"><a href="#2-最大值-与-n1-n2-…-n-1" class="headerlink" title="2.最大值 与 n1 + n2 + … + n-1"></a>2.最大值 与 n1 + n2 + … + n-1</h1><h1 id="if-gt-1"><a href="#if-gt-1" class="headerlink" title="if     &gt;       -1"></a>if     &gt;       -1</h1><h1 id="如果-lt"><a href="#如果-lt" class="headerlink" title="如果   &lt;"></a>如果   &lt;</h1><h1 id="最大值-次大值-与-n1-n2-…-n-2"><a href="#最大值-次大值-与-n1-n2-…-n-2" class="headerlink" title="最大值 + 次大值 与 n1 + n2 + … + n-2"></a>最大值 + 次大值 与 n1 + n2 + … + n-2</h1><h1 id="类推"><a href="#类推" class="headerlink" title="类推"></a>类推</h1><h1 id="有相等的-输出，无-1"><a href="#有相等的-输出，无-1" class="headerlink" title="有相等的 输出，无 -1"></a>有相等的 输出，无 -1</h1><p>通过率又是 30%，我就采取以上的大致思路，最大值，次大值，类推下去<br>正确答案(牛客网暂无)：</p><p>这题 python 解决的答案无，我就要举报牛客了，下面这里显示只有一个人，他答案还是不对的哟。</p><p>待大神解决。</p><p>12.<br>易老师购买了一盒饼干，盒子中一共有k块饼干，但是数字k有些数位变得模糊了，看不清楚数字具体是多少了。易老师需要你帮忙把这k块饼干平分给n个小朋友，易老师保证这盒饼干能平分给n个小朋友。现在你需要计算出k有多少种可能的数值<br>输入描述:</p><p>输入包括两行：</p><p>第一行为盒子上的数值k，模糊的数位用X表示，长度小于18(可能有多个模糊的数位)</p><p>第二行为小朋友的人数n</p><p>输出描述:</p><p>输出k可能的数值种数，保证至少为1</p><p>输入例子:</p><p>9999999999999X<br>3</p><p>输出例子:</p><p>4</p><p>个人思路：</p><h1 id="难度在于，输入的是数字还是字符串，如何分离"><a href="#难度在于，输入的是数字还是字符串，如何分离" class="headerlink" title="难度在于，输入的是数字还是字符串，如何分离"></a>难度在于，输入的是数字还是字符串，如何分离</h1><h1 id="999999X9999999X9999-类似这种情况"><a href="#999999X9999999X9999-类似这种情况" class="headerlink" title="999999X9999999X9999 类似这种情况"></a>999999X9999999X9999 类似这种情况</h1><h1 id="找-X-的位置，记录，确定有几位"><a href="#找-X-的位置，记录，确定有几位" class="headerlink" title="找 X 的位置，记录，确定有几位"></a>找 X 的位置，记录，确定有几位</h1><h1 id="依次分配，"><a href="#依次分配，" class="headerlink" title="依次分配，"></a>依次分配，</h1><h1 id="用不成-for-因为不知道有几重"><a href="#用不成-for-因为不知道有几重" class="headerlink" title="用不成 for,因为不知道有几重"></a>用不成 for,因为不知道有几重</h1><p>比如 X 出现 3 次，出现的下标为 3，5，6，我都可以记录下来。</p><p>问题在于现在我要生成 [‘0’, ‘0’, ‘0’] 到 [‘9’, ‘9’, ‘9’]的全部组合。卡在了这里。但是，这个思路是不对的，因为如果 X 太多，那么计算太费时了！<br>正确答案(牛客网 id：周昆)：</p><p>k = raw_input()</p><p>n = int(raw_input())</p><p>remainders = [1] + [0] * (n - 1)</p><p>for i, s in enumerate(k):</p><pre><code>temp = [0] * nif s != &apos;X&apos;:    s = int(s)    for j in range(n):        temp[(j*10+s) % n] += remainders[j]else:    for s in range(10):        for j in range(n):            temp[(j*10+s) % n] += remainders[j]remainders = temp</code></pre><p>print remainders[0]<br>这里说是用到状态转移方程，temp[(j*10+s) % n] += remainders[j] 是最关键的一句。望大家一起研究。</p><p>我觉得做这些题，都是需要将对应的问题转换成我们熟悉的代码，比如回溯，背包，动态规划，还有对数学的要求也不是盖的。</p><p>总之，理解题目，找好算法，理清逻辑，必要时写一个或几个功能函数，继续学习。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[编程题] 彩色的砖块&lt;/p&gt;
&lt;p&gt;时间限制：1秒&lt;/p&gt;
&lt;p&gt;空间限制：32768K&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;小易有一些彩色的砖块。每种颜色由一个大写字母表示。各个颜色砖块看起来都完全一样。现在有一个给定的字符串s,s中每个字符代表小易的某个砖块的颜色。小易想把
      
    
    </summary>
    
    
  </entry>
  
</feed>
